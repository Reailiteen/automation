{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/auth/src/client.ts"],"sourcesContent":["import { createBrowserClient } from \"@supabase/ssr\";\n\nexport function createClient() {\n  const supabaseUrl = (process.env.NEXT_PUBLIC_SUPABASE_URL ?? \"\").trim();\n  const supabaseAnonKey = (process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ?? \"\").trim();\n\n  if (!supabaseUrl || !supabaseAnonKey) {\n    throw new Error(\n      \"Missing Supabase env: NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY\"\n    );\n  }\n\n  return createBrowserClient(supabaseUrl, supabaseAnonKey);\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEO,SAAS;IACd,MAAM,cAAc,CAAC,gFAAwC,EAAE,EAAE,IAAI;IACrE,MAAM,kBAAkB,CAAC,wPAA6C,EAAE,EAAE,IAAI;IAE9E,IAAI,CAAC,eAAe,CAAC,iBAAiB;QACpC,MAAM,IAAI,MACR;IAEJ;IAEA,OAAO,IAAA,gTAAmB,EAAC,aAAa;AAC1C"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/auth/src/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  const supabaseUrl = (process.env.NEXT_PUBLIC_SUPABASE_URL ?? \"\").trim();\n  const supabaseAnonKey = (process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ?? \"\").trim();\n\n  if (!supabaseUrl || !supabaseAnonKey) {\n    throw new Error(\n      'Missing Supabase environment variables. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY in your .env.local file.'\n    );\n  }\n\n  return createServerClient(\n    supabaseUrl,\n    supabaseAnonKey,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet: { name: string; value: string; options?: Record<string, unknown> }[]) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,iWAAO;IAEjC,MAAM,cAAc,CAAC,gFAAwC,EAAE,EAAE,IAAI;IACrE,MAAM,kBAAkB,CAAC,wPAA6C,EAAE,EAAE,IAAI;IAE9E,IAAI,CAAC,eAAe,CAAC,iBAAiB;QACpC,MAAM,IAAI,MACR;IAEJ;IAEA,OAAO,IAAA,8SAAkB,EACvB,aACA,iBACA;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAkF;gBACvF,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ"}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/auth/src/index.ts"],"sourcesContent":["// Export Supabase clients\nexport { createClient as createBrowserClient } from './client';\nexport { createClient as createServerClient } from './server';\n"],"names":[],"mappings":";AAAA,0BAA0B;AAC1B;AACA"}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/storage.ts"],"sourcesContent":["import { promises as fs } from 'fs';\nimport path from 'path';\nimport { Task, Plan, User, Schedule, AgentOutput, Project } from '@automation/types';\n\n// Detect if we're in a serverless environment (Netlify Functions, AWS Lambda, etc.)\n// In serverless, filesystem is read-only except for /tmp\nfunction detectServerless(): boolean {\n  const cwd = process.cwd();\n  return !!(\n    process.env.NETLIFY === 'true' ||\n    process.env.AWS_LAMBDA_FUNCTION_NAME ||\n    process.env.VERCEL === '1' ||\n    process.env.LAMBDA_TASK_ROOT ||\n    cwd.includes('/var/task') ||\n    cwd === '/var/task' ||\n    cwd.startsWith('/tmp') ||\n    // Additional check: if cwd is a typical serverless path\n    (cwd.startsWith('/') && !cwd.includes('Desktop') && !cwd.includes('home') && !cwd.includes('Users'))\n  );\n}\n\nfunction getDataDir(): string {\n  const isServerless = detectServerless();\n  // Always use /tmp in serverless - it's the only writable location\n  if (isServerless) {\n    console.log('[STORAGE] Serverless environment detected, using /tmp for data storage');\n    return path.join('/tmp', 'automation-data');\n  }\n  return path.join(process.cwd(), 'data');\n}\n\nconst DATA_DIR = getDataDir();\nconst TASKS_FILE = path.join(DATA_DIR, 'tasks.json');\nconst PLANS_FILE = path.join(DATA_DIR, 'plans.json');\nconst PROJECTS_FILE = path.join(DATA_DIR, 'projects.json');\nconst USERS_FILE = path.join(DATA_DIR, 'users.json');\nconst SCHEDULES_FILE = path.join(DATA_DIR, 'schedules.json');\nconst AGENT_OUTPUTS_FILE = path.join(DATA_DIR, 'agent-outputs.json');\n\n// Initialize data directory and files\nasync function ensureDataDir() {\n  const isServerless = detectServerless();\n  try {\n    await fs.mkdir(DATA_DIR, { recursive: true });\n\n    // Create empty JSON files if they don't exist\n    for (const file of [TASKS_FILE, PLANS_FILE, PROJECTS_FILE, USERS_FILE, SCHEDULES_FILE, AGENT_OUTPUTS_FILE]) {\n      try {\n        await fs.access(file);\n      } catch {\n        await fs.writeFile(file, '[]');\n      }\n    }\n  } catch (error: any) {\n    // In serverless, if /tmp fails, log but don't throw - we'll handle gracefully\n    if (isServerless && (error.code === 'EROFS' || error.message?.includes('read-only'))) {\n      console.warn('Read-only filesystem detected in serverless environment.');\n      console.warn('Data will not persist. Please migrate to Supabase for production storage.');\n      // Return empty arrays for reads, and log writes (data won't persist)\n      return;\n    }\n    console.error('Error ensuring data directory:', error);\n    throw error;\n  }\n}\n\n// Generic file operations\nasync function readFile<T>(filePath: string): Promise<T[]> {\n  await ensureDataDir();\n  try {\n    const data = await fs.readFile(filePath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Error reading file:', error);\n    return [];\n  }\n}\n\nasync function writeFile<T>(filePath: string, data: T[]): Promise<void> {\n  const isServerless = detectServerless();\n  await ensureDataDir();\n  try {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2));\n  } catch (error: any) {\n    // Handle read-only filesystem in serverless\n    if (error.code === 'EROFS' || error.message?.includes('read-only')) {\n      const errorMsg = `[STORAGE] Cannot write to ${filePath}: Read-only filesystem. ` +\n        `This is expected in serverless environments. Data will not persist between invocations. ` +\n        `Please migrate to Supabase for persistent storage in production.`;\n      console.warn(errorMsg);\n      // Don't throw - allow the app to continue (data just won't persist)\n      // In serverless, /tmp is writable but cleared between invocations\n      return;\n    }\n    console.error('Error writing file:', error);\n    throw error;\n  }\n}\n\n// Task operations\nexport const taskStorage = {\n  getAll: (): Promise<Task[]> => readFile<Task>(TASKS_FILE),\n  byId: async (id: string): Promise<Task | undefined> => {\n    const tasks = await readFile<Task>(TASKS_FILE);\n    return tasks.find(task => task.id === id);\n  },\n  byPlan: async (planId: string): Promise<Task[]> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    const plan = plans.find(p => p.id === planId);\n    if (!plan) return [];\n\n    const tasks = await readFile<Task>(TASKS_FILE);\n    return tasks.filter(task => plan.tasks.includes(task.id));\n  },\n  save: async (task: Task): Promise<void> => {\n    const tasks = await readFile<Task>(TASKS_FILE);\n    const index = tasks.findIndex(t => t.id === task.id);\n\n    if (index >= 0) {\n      // Update existing task\n      tasks[index] = task;\n    } else {\n      // Add new task\n      tasks.push(task);\n    }\n\n    await writeFile(TASKS_FILE, tasks);\n  },\n  delete: async (id: string): Promise<void> => {\n    const tasks = await readFile<Task>(TASKS_FILE);\n    const filtered = tasks.filter(task => task.id !== id);\n    await writeFile(TASKS_FILE, filtered);\n  }\n};\n\n// Plan operations\nexport const planStorage = {\n  getAll: (): Promise<Plan[]> => readFile<Plan>(PLANS_FILE),\n  byId: async (id: string): Promise<Plan | undefined> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    return plans.find(plan => plan.id === id);\n  },\n  save: async (plan: Plan): Promise<void> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    const index = plans.findIndex(p => p.id === plan.id);\n\n    if (index >= 0) {\n      plans[index] = plan;\n    } else {\n      plans.push(plan);\n    }\n\n    await writeFile(PLANS_FILE, plans);\n  },\n  delete: async (id: string): Promise<void> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    const filtered = plans.filter(plan => plan.id !== id);\n    await writeFile(PLANS_FILE, filtered);\n  }\n};\n\n// Project operations\nexport const projectStorage = {\n  getAll: (): Promise<Project[]> => readFile<Project>(PROJECTS_FILE),\n  byId: async (id: string): Promise<Project | undefined> => {\n    const projects = await readFile<Project>(PROJECTS_FILE);\n    return projects.find(p => p.id === id);\n  },\n  save: async (project: Project): Promise<void> => {\n    const projects = await readFile<Project>(PROJECTS_FILE);\n    const index = projects.findIndex(p => p.id === project.id);\n    if (index >= 0) projects[index] = project;\n    else projects.push(project);\n    await writeFile(PROJECTS_FILE, projects);\n  },\n  delete: async (id: string): Promise<void> => {\n    const projects = await readFile<Project>(PROJECTS_FILE);\n    await writeFile(PROJECTS_FILE, projects.filter(p => p.id !== id));\n  },\n};\n\n// User operations\nexport const userStorage = {\n  getAll: (): Promise<User[]> => readFile<User>(USERS_FILE),\n  byId: async (id: string): Promise<User | undefined> => {\n    const users = await readFile<User>(USERS_FILE);\n    return users.find(user => user.id === id);\n  },\n  save: async (user: User): Promise<void> => {\n    const users = await readFile<User>(USERS_FILE);\n    const index = users.findIndex(u => u.id === user.id);\n\n    if (index >= 0) {\n      users[index] = user;\n    } else {\n      users.push(user);\n    }\n\n    await writeFile(USERS_FILE, users);\n  }\n};\n\n// Schedule operations\nexport const scheduleStorage = {\n  getAll: (): Promise<Schedule[]> => readFile<Schedule>(SCHEDULES_FILE),\n  byDate: async (date: Date): Promise<Schedule | undefined> => {\n    const schedules = await readFile<Schedule>(SCHEDULES_FILE);\n    return schedules.find(schedule =>\n      new Date(schedule.date).toDateString() === date.toDateString()\n    );\n  },\n  save: async (schedule: Schedule): Promise<void> => {\n    const schedules = await readFile<Schedule>(SCHEDULES_FILE);\n    const index = schedules.findIndex(s => s.id === schedule.id);\n\n    if (index >= 0) {\n      schedules[index] = schedule;\n    } else {\n      schedules.push(schedule);\n    }\n\n    await writeFile(SCHEDULES_FILE, schedules);\n  }\n};\n\n// Agent output operations\nexport const agentOutputStorage = {\n  getAll: (): Promise<AgentOutput[]> => readFile<AgentOutput>(AGENT_OUTPUTS_FILE),\n  save: async (output: AgentOutput): Promise<void> => {\n    const outputs = await readFile<AgentOutput>(AGENT_OUTPUTS_FILE);\n    outputs.push(output);\n    await writeFile(AGENT_OUTPUTS_FILE, outputs);\n  }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/supabase-client.ts"],"sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js';\n\nlet supabase: SupabaseClient | null = null;\n\nconst supabaseUrl = process.env.SUPABASE_URL?.trim();\nconst supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY?.trim();\n\nif (supabaseUrl && supabaseKey) {\n  supabase = createClient(supabaseUrl, supabaseKey, {\n    auth: { persistSession: false },\n  });\n} else if (process.env.SUPABASE_URL && process.env.SUPABASE_ANON_KEY) {\n  // For environments that only provide the anon key (e.g., web)\n  supabase = createClient(process.env.SUPABASE_URL.trim(), process.env.SUPABASE_ANON_KEY.trim());\n}\n\nexport function getSupabase() {\n  return supabase;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA,IAAI,WAAkC;AAEtC,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY,EAAE;AAC9C,MAAM,cAAc,QAAQ,GAAG,CAAC,yBAAyB,EAAE;AAE3D,IAAI,eAAe,aAAa;IAC9B,WAAW,IAAA,0QAAY,EAAC,aAAa,aAAa;QAChD,MAAM;YAAE,gBAAgB;QAAM;IAChC;AACF,OAAO,IAAI,QAAQ,GAAG,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,iBAAiB,EAAE;IACpE,8DAA8D;IAC9D,WAAW,IAAA,0QAAY,EAAC,QAAQ,GAAG,CAAC,YAAY,CAAC,IAAI,IAAI,QAAQ,GAAG,CAAC,iBAAiB,CAAC,IAAI;AAC7F;AAEO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/repositories.ts"],"sourcesContent":["import { Task, Plan, User, Schedule, AgentOutput, Project, TaskKind, ScheduledTask } from '@automation/types';\nimport { taskStorage, planStorage, projectStorage, userStorage, scheduleStorage, agentOutputStorage } from './storage';\nimport { getSupabase } from './supabase-client';\n\n// Utility function to generate IDs\nfunction generateId(): string {\n  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\n\nconst supabaseClient = getSupabase();\n\nconst ensureArray = (value: unknown): string[] => {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string' && value.length) {\n    try {\n      const parsed = JSON.parse(value);\n      if (Array.isArray(parsed)) return parsed;\n    } catch {\n      return value.split(',').map((it) => it.trim()).filter(Boolean);\n    }\n  }\n  return [];\n};\n\nconst mapTaskRecord = (record: any): Task => {\n  const normalized = {\n    ...record,\n    estimatedTime: record.estimated_time ?? record.estimatedTime ?? 0,\n    actualTime: record.actual_time ?? record.actualTime,\n    focusLevel: record.focus_level ?? record.focusLevel ?? 'medium',\n    dueDate: record.due_date ? new Date(record.due_date) : record.dueDate ? new Date(record.dueDate) : undefined,\n    createdAt: record.created_at ? new Date(record.created_at) : record.createdAt ? new Date(record.createdAt) : new Date(),\n    updatedAt: record.updated_at ? new Date(record.updated_at) : record.updatedAt ? new Date(record.updatedAt) : new Date(),\n    parentTaskId: record.parent_task_id ?? record.parentTaskId,\n    subtasks: ensureArray(record.subtasks ?? record.subtasks_json),\n    dependencies: ensureArray(record.dependencies ?? record.dependencies_json),\n    tags: ensureArray(record.tags ?? record.tags_json),\n    energyRequirement: record.energy_requirement ?? record.energyRequirement ?? 'medium',\n    context: record.context ?? record.location ?? 'anywhere',\n    isRecurring: record.is_recurring ?? record.isRecurring,\n    recurrencePattern: record.recurrence_pattern ?? record.recurrencePattern,\n    kind: record.kind ?? 'todo',\n    projectId: record.project_id ?? record.projectId,\n    recurrencePerWeek: record.recurrence_per_week ?? record.recurrencePerWeek,\n    userId: record.user_id ?? record.userId,\n  };\n\n  return {\n    id: normalized.id,\n    title: normalized.title,\n    description: normalized.description,\n    status: normalized.status,\n    priority: normalized.priority,\n    estimatedTime: normalized.estimatedTime,\n    actualTime: normalized.actualTime,\n    focusLevel: normalized.focusLevel,\n    dueDate: normalized.dueDate,\n    createdAt: normalized.createdAt,\n    updatedAt: normalized.updatedAt,\n    parentTaskId: normalized.parentTaskId,\n    subtasks: normalized.subtasks,\n    dependencies: normalized.dependencies,\n    tags: normalized.tags,\n    energyRequirement: normalized.energyRequirement,\n    context: normalized.context,\n    isRecurring: normalized.isRecurring,\n    recurrencePattern: normalized.recurrencePattern,\n    kind: normalized.kind,\n    projectId: normalized.projectId,\n    recurrencePerWeek: normalized.recurrencePerWeek,\n    userId: normalized.userId,\n  };\n};\n\nconst buildTaskPayload = (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Record<string, any> => ({\n  title: task.title,\n  description: task.description ?? null,\n  status: task.status,\n  priority: task.priority,\n  estimated_time: task.estimatedTime,\n  actual_time: task.actualTime ?? null,\n  focus_level: task.focusLevel,\n  due_date: task.dueDate ? task.dueDate.toISOString() : null,\n  parent_task_id: task.parentTaskId ?? null,\n  subtasks: task.subtasks ?? [],\n  dependencies: task.dependencies ?? [],\n  tags: task.tags ?? [],\n  energy_requirement: task.energyRequirement,\n  context: task.context,\n  is_recurring: task.isRecurring ?? false,\n  recurrence_pattern: task.recurrencePattern ?? null,\n  kind: task.kind ?? 'todo',\n  project_id: task.projectId ?? null,\n  recurrence_per_week: task.recurrencePerWeek ?? null,\n  user_id: task.userId ?? null,\n});\n\nconst buildTaskUpdatePayload = (\n  updates: Partial<Omit<Task, 'id' | 'createdAt'>>\n): Record<string, any> => {\n  const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n  if (updates.title !== undefined) payload.title = updates.title;\n  if (updates.description !== undefined) payload.description = updates.description;\n  if (updates.status !== undefined) payload.status = updates.status;\n  if (updates.priority !== undefined) payload.priority = updates.priority;\n  if (updates.estimatedTime !== undefined) payload.estimated_time = updates.estimatedTime;\n  if (updates.actualTime !== undefined) payload.actual_time = updates.actualTime;\n  if (updates.focusLevel !== undefined) payload.focus_level = updates.focusLevel;\n  if (updates.dueDate !== undefined) payload.due_date = updates.dueDate ? updates.dueDate.toISOString() : null;\n  if (updates.parentTaskId !== undefined) payload.parent_task_id = updates.parentTaskId;\n  if (updates.subtasks !== undefined) payload.subtasks = updates.subtasks;\n  if (updates.dependencies !== undefined) payload.dependencies = updates.dependencies;\n  if (updates.tags !== undefined) payload.tags = updates.tags;\n  if (updates.energyRequirement !== undefined) payload.energy_requirement = updates.energyRequirement;\n  if (updates.context !== undefined) payload.context = updates.context;\n  if (updates.isRecurring !== undefined) payload.is_recurring = updates.isRecurring;\n  if (updates.recurrencePattern !== undefined) payload.recurrence_pattern = updates.recurrencePattern;\n  if (updates.kind !== undefined) payload.kind = updates.kind;\n  if (updates.projectId !== undefined) payload.project_id = updates.projectId;\n  if (updates.recurrencePerWeek !== undefined) payload.recurrence_per_week = updates.recurrencePerWeek;\n  if (updates.userId !== undefined) payload.user_id = updates.userId;\n  return payload;\n};\n\nconst parseJsonField = (value: unknown, fallback: any = null) => {\n  if (value === null || value === undefined) return fallback;\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value);\n    } catch {\n      return fallback;\n    }\n  }\n  return value;\n};\n\nconst normalizeScheduledTasks = (value: unknown): ScheduledTask[] => {\n  const raw = Array.isArray(value) ? value : [];\n  return raw.map((task: any) => ({\n    taskId: task.taskId ?? task.task_id ?? '',\n    scheduledStart: task.scheduledStart\n      ? new Date(task.scheduledStart)\n      : task.scheduled_start\n      ? new Date(task.scheduled_start)\n      : new Date(),\n    scheduledEnd: task.scheduledEnd\n      ? new Date(task.scheduledEnd)\n      : task.scheduled_end\n      ? new Date(task.scheduled_end)\n      : new Date(),\n    actualStart: task.actualStart\n      ? new Date(task.actualStart)\n      : task.actual_start\n      ? new Date(task.actual_start)\n      : undefined,\n    actualEnd: task.actualEnd\n      ? new Date(task.actualEnd)\n      : task.actual_end\n      ? new Date(task.actual_end)\n      : undefined,\n    status: task.status ?? 'scheduled',\n    location: task.location ?? null,\n    context: task.context ?? null,\n  }));\n};\n\nconst serializeScheduledTasks = (tasks: ScheduledTask[]): any[] =>\n  tasks.map((task) => ({\n    taskId: task.taskId,\n    scheduledStart: task.scheduledStart.toISOString(),\n    scheduledEnd: task.scheduledEnd.toISOString(),\n    actualStart: task.actualStart ? task.actualStart.toISOString() : null,\n    actualEnd: task.actualEnd ? task.actualEnd.toISOString() : null,\n    status: task.status,\n    location: task.location ?? null,\n    context: task.context ?? null,\n  }));\n\nconst mapPlanRecord = (record: any): Plan => ({\n  id: record.id,\n  title: record.title,\n  description: record.description,\n  status: record.status,\n  tasks: ensureArray(record.tasks ?? record.task_ids),\n  createdAt: record.created_at ? new Date(record.created_at) : new Date(),\n  updatedAt: record.updated_at ? new Date(record.updated_at) : new Date(),\n  startDate: record.start_date ? new Date(record.start_date) : undefined,\n  endDate: record.end_date ? new Date(record.end_date) : undefined,\n  goal: record.goal ?? '',\n  constraints: parseJsonField(record.constraints, {}),\n  userId: record.user_id ?? undefined,\n});\n\nconst buildPlanPayload = (plan: Omit<Plan, 'id' | 'createdAt' | 'updatedAt'>): Record<string, any> => ({\n  title: plan.title,\n  description: plan.description ?? null,\n  status: plan.status,\n  tasks: plan.tasks ?? [],\n  start_date: plan.startDate ? plan.startDate.toISOString() : null,\n  end_date: plan.endDate ? plan.endDate.toISOString() : null,\n  goal: plan.goal,\n  constraints: plan.constraints ?? {},\n  user_id: plan.userId ?? null,\n});\n\nconst buildPlanUpdatePayload = (\n  updates: Partial<Omit<Plan, 'id' | 'createdAt'>>\n): Record<string, any> => {\n  const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n  if (updates.title !== undefined) payload.title = updates.title;\n  if (updates.description !== undefined) payload.description = updates.description;\n  if (updates.status !== undefined) payload.status = updates.status;\n  if (updates.tasks !== undefined) payload.tasks = updates.tasks;\n  if (updates.startDate !== undefined)\n    payload.start_date = updates.startDate ? updates.startDate.toISOString() : null;\n  if (updates.endDate !== undefined)\n    payload.end_date = updates.endDate ? updates.endDate.toISOString() : null;\n  if (updates.goal !== undefined) payload.goal = updates.goal;\n  if (updates.constraints !== undefined) payload.constraints = updates.constraints;\n  if (updates.userId !== undefined) payload.user_id = updates.userId;\n  return payload;\n};\n\nconst mapScheduleRecord = (record: any): Schedule => ({\n  id: record.id,\n  date: record.date ? new Date(record.date) : new Date(),\n  tasks: normalizeScheduledTasks(parseJsonField(record.tasks, [])),\n  notes: record.notes ?? '',\n  energyProfile: parseJsonField(record.energy_profile, {\n    peakHours: [],\n    mediumHours: [],\n    lowHours: [],\n    recoveryTime: 0,\n  }),\n  constraints: parseJsonField(record.constraints, { maxTasks: 0, maxDeepWorkSessions: 0 }),\n  validation: parseJsonField(record.validation, undefined),\n  userId: record.user_id ?? undefined,\n  createdAt: record.created_at ? new Date(record.created_at) : new Date(),\n  updatedAt: record.updated_at ? new Date(record.updated_at) : new Date(),\n});\n\nconst buildSchedulePayload = (\n  schedule: Omit<Schedule, 'id' | 'createdAt' | 'updatedAt'>\n): Record<string, any> => ({\n  date: schedule.date.toISOString(),\n  tasks: serializeScheduledTasks(schedule.tasks ?? []),\n  notes: schedule.notes ?? '',\n  energy_profile: schedule.energyProfile ?? {},\n  constraints: schedule.constraints ?? {},\n  validation: schedule.validation ?? null,\n  user_id: schedule.userId ?? null,\n});\n\n// Task Repository\nexport const taskRepo = {\n  getAll: async (options?: { userId?: string }): Promise<Task[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('tasks').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n\n        const { data, error } = await query;\n        if (error) {\n          console.warn('Supabase task fetch error:', error.message);\n        } else if (data) {\n          return data.map(mapTaskRecord);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    return await taskStorage.getAll();\n  },\n  \n  getById: async (id: string): Promise<Task | null> => {\n    if (supabaseClient) {\n      try {\n        const { data, error } = await supabaseClient\n          .from('tasks')\n          .select('*')\n          .eq('id', id)\n          .single();\n\n        if (!error && data) {\n          return mapTaskRecord(data);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase getById failed:', error);\n      }\n    }\n\n    const task = await taskStorage.byId(id);\n    return task || null;\n  },\n  \n  create: async (taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          ...buildTaskPayload(taskData),\n          id: generateId(),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('tasks')\n          .insert(payload)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapTaskRecord(data);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const task: Task = {\n      ...taskData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n    \n    await taskStorage.save(task);\n    return task;\n  },\n  \n  update: async (id: string, updates: Partial<Omit<Task, 'id' | 'createdAt'>>): Promise<Task | null> => {\n    if (supabaseClient) {\n      try {\n        const payload = buildTaskUpdatePayload(updates);\n        const { data, error } = await supabaseClient\n          .from('tasks')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapTaskRecord(data);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase update failed:', error);\n      }\n    }\n\n    const task = await taskStorage.byId(id);\n    if (!task) return null;\n    \n    const updatedTask: Task = {\n      ...task,\n      ...updates,\n      updatedAt: new Date()\n    };\n    \n    await taskStorage.save(updatedTask);\n    return updatedTask;\n  },\n  \n  delete: async (id: string): Promise<boolean> => {\n    if (supabaseClient) {\n      try {\n        const { error } = await supabaseClient\n          .from('tasks')\n          .delete()\n          .eq('id', id);\n\n        if (!error) {\n          return true;\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase delete failed:', error);\n      }\n    }\n\n    try {\n      await taskStorage.delete(id);\n      return true;\n    } catch (error) {\n      console.error('Error deleting task:', error);\n      return false;\n    }\n  },\n  \n  getByPlan: async (planId: string): Promise<Task[]> => {\n    return await taskStorage.byPlan(planId);\n  },\n  \n  // Find tasks that are due soon\n  getByDueDate: async (startDate: Date, endDate: Date): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => {\n      if (!task.dueDate) return false;\n      const dueDate = new Date(task.dueDate);\n      return dueDate >= startDate && dueDate <= endDate;\n    });\n  },\n  \n  // Find tasks with specific tags\n  getByTags: async (tags: string[]): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => \n      tags.some(tag => task.tags.includes(tag))\n    );\n  },\n  \n  // Get tasks with specific status\n  getByStatus: async (status: Task['status']): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => task.status === status);\n  },\n\n  getByProject: async (projectId: string): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => task.projectId === projectId);\n  },\n\n  getByKind: async (kind: TaskKind): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => (task.kind ?? 'todo') === kind);\n  },\n};\n\n// Plan Repository\nexport const planRepo = {\n  getAll: async (options?: { userId?: string }): Promise<Plan[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('plans').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (error) {\n          console.warn('[planRepo] Supabase getAll error:', error.message);\n        } else if (data) {\n          return data.map(mapPlanRecord);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    return await planStorage.getAll();\n  },\n  \n  getById: async (id: string): Promise<Plan | null> => {\n    if (supabaseClient) {\n      try {\n        const { data, error } = await supabaseClient\n          .from('plans')\n          .select('*')\n          .eq('id', id)\n          .single();\n\n        if (!error && data) {\n          return mapPlanRecord(data);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase getById failed:', error);\n      }\n    }\n\n    const plan = await planStorage.byId(id);\n    return plan || null;\n  },\n  \n  create: async (planData: Omit<Plan, 'id' | 'createdAt' | 'updatedAt'>): Promise<Plan> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          id: generateId(),\n          ...buildPlanPayload(planData),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('plans')\n          .insert(payload)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapPlanRecord(data);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const plan: Plan = {\n      ...planData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n    \n    await planStorage.save(plan);\n    return plan;\n  },\n  \n  update: async (id: string, updates: Partial<Omit<Plan, 'id' | 'createdAt'>>): Promise<Plan | null> => {\n    if (supabaseClient) {\n      try {\n        const payload = buildPlanUpdatePayload(updates);\n        const { data, error } = await supabaseClient\n          .from('plans')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapPlanRecord(data);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase update failed:', error);\n      }\n    }\n\n    const plan = await planStorage.byId(id);\n    if (!plan) return null;\n    \n    const updatedPlan: Plan = {\n      ...plan,\n      ...updates,\n      updatedAt: new Date()\n    };\n    \n    await planStorage.save(updatedPlan);\n    return updatedPlan;\n  },\n  \n  delete: async (id: string): Promise<boolean> => {\n    if (supabaseClient) {\n      try {\n        const { error } = await supabaseClient\n          .from('plans')\n          .delete()\n          .eq('id', id);\n\n        if (!error) {\n          return true;\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase delete failed:', error);\n      }\n    }\n\n    try {\n      await planStorage.delete(id);\n      return true;\n    } catch (error) {\n      console.error('Error deleting plan:', error);\n      return false;\n    }\n  },\n  \n  getByStatus: async (status: Plan['status'], options?: { userId?: string }): Promise<Plan[]> => {\n    const plans = await planRepo.getAll(options);\n    return plans.filter(plan => plan.status === status);\n  }\n};\n\n// Project Repository\nexport const projectRepo = {\n  getAll: async (): Promise<Project[]> => await projectStorage.getAll(),\n  getById: async (id: string): Promise<Project | null> => {\n    const p = await projectStorage.byId(id);\n    return p ?? null;\n  },\n  create: async (data: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<Project> => {\n    const now = new Date();\n    const project: Project = {\n      ...data,\n      id: generateId(),\n      taskIds: data.taskIds || [],\n      createdAt: now,\n      updatedAt: now,\n    };\n    await projectStorage.save(project);\n    return project;\n  },\n  update: async (id: string, updates: Partial<Omit<Project, 'id' | 'createdAt'>>): Promise<Project | null> => {\n    const project = await projectStorage.byId(id);\n    if (!project) return null;\n    const updated = { ...project, ...updates, updatedAt: new Date() };\n    await projectStorage.save(updated);\n    return updated;\n  },\n  delete: async (id: string): Promise<boolean> => {\n    try {\n      await projectStorage.delete(id);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n};\n\n// User Repository\nexport const userRepo = {\n  getAll: async (): Promise<User[]> => {\n    return await userStorage.getAll();\n  },\n\n  getById: async (id: string): Promise<User | null> => {\n    const user = await userStorage.byId(id);\n    return user || null;\n  },\n\n  create: async (userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>, id?: string): Promise<User> => {\n    const now = new Date();\n    const user: User = {\n      ...userData,\n      id: id || generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n\n    await userStorage.save(user);\n    return user;\n  },\n\n  update: async (id: string, updates: Partial<Omit<User, 'id' | 'createdAt'>>): Promise<User | null> => {\n    const user = await userStorage.byId(id);\n    if (!user) return null;\n\n    const updatedUser: User = {\n      ...user,\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    await userStorage.save(updatedUser);\n    return updatedUser;\n  }\n};\n\n// Schedule Repository\nexport const scheduleRepo = {\n  getAll: async (options?: { userId?: string }): Promise<Schedule[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('schedules').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (error) {\n          console.warn('[scheduleRepo] Supabase getAll error:', error.message);\n        } else if (data) {\n          return data.map(mapScheduleRecord);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    return await scheduleStorage.getAll();\n  },\n\n  getByDate: async (date: Date, options?: { userId?: string }): Promise<Schedule | null> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient\n          .from('schedules')\n          .select('*')\n          .eq('date', date.toISOString().split('T')[0]);\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (!error && data && data.length) {\n          return mapScheduleRecord(data[0]);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase getByDate failed:', error);\n      }\n    }\n\n    const schedule = await scheduleStorage.byDate(date);\n    return schedule || null;\n  },\n\n  create: async (scheduleData: Omit<Schedule, 'id' | 'createdAt' | 'updatedAt'>): Promise<Schedule> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          id: generateId(),\n          ...buildSchedulePayload(scheduleData),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('schedules')\n          .insert(payload)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapScheduleRecord(data);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const schedule: Schedule = {\n      ...scheduleData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n\n    await scheduleStorage.save(schedule);\n    return schedule;\n  },\n\n  update: async (id: string, updates: Partial<Omit<Schedule, 'id' | 'createdAt'>>): Promise<Schedule | null> => {\n    if (supabaseClient) {\n      try {\n        const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n        if (updates.date !== undefined) payload.date = updates.date.toISOString();\n        if (updates.tasks !== undefined) payload.tasks = updates.tasks;\n        if (updates.notes !== undefined) payload.notes = updates.notes;\n        if (updates.energyProfile !== undefined) payload.energy_profile = updates.energyProfile;\n        if (updates.constraints !== undefined) payload.constraints = updates.constraints;\n        if (updates.validation !== undefined) payload.validation = updates.validation;\n        if (updates.userId !== undefined) payload.user_id = updates.userId;\n\n        const { data, error } = await supabaseClient\n          .from('schedules')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapScheduleRecord(data);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase update failed:', error);\n      }\n    }\n\n    const schedules = await scheduleStorage.getAll();\n    const schedule = schedules.find(s => s.id === id);\n    if (!schedule) return null;\n\n    const updatedSchedule: Schedule = {\n      ...schedule,\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    await scheduleStorage.save(updatedSchedule);\n    return updatedSchedule;\n  },\n\n  getByDateRange: async (startDate: Date, endDate: Date, options?: { userId?: string }): Promise<Schedule[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient\n          .from('schedules')\n          .select('*')\n          .gte('date', startDate.toISOString().split('T')[0])\n          .lte('date', endDate.toISOString().split('T')[0]);\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (!error && data) {\n          return data.map(mapScheduleRecord);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase getByDateRange failed:', error);\n      }\n    }\n\n    const schedules = await scheduleStorage.getAll();\n    return schedules.filter(schedule => {\n      const scheduleDate = new Date(schedule.date);\n      return scheduleDate >= startDate && scheduleDate <= endDate;\n    });\n  }\n};\n\n// Agent Output Repository\nexport const agentOutputRepo = {\n  getAll: async (): Promise<AgentOutput[]> => {\n    return await agentOutputStorage.getAll();\n  },\n\n  create: async (outputData: Omit<AgentOutput, 'timestamp'>): Promise<AgentOutput> => {\n    const output: AgentOutput = {\n      ...outputData,\n      timestamp: new Date()\n    };\n\n    await agentOutputStorage.save(output);\n    return output;\n  },\n\n  getByAgentType: async (agentType: AgentOutput['agentType']): Promise<AgentOutput[]> => {\n    const outputs = await agentOutputStorage.getAll();\n    return outputs.filter(output => output.agentType === agentType);\n  }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1062, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/index.ts"],"sourcesContent":["// Export storage layer\nexport * from './storage';\n\n// Export repositories\nexport * from './repositories';\n"],"names":[],"mappings":";AAAA,uBAAuB;AACvB;AAEA,sBAAsB;AACtB"}},
    {"offset": {"line": 1073, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/env.ts"],"sourcesContent":["// Platform-agnostic environment variable access\n// Works in both Node.js (web) and React Native (mobile)\n\nlet expoConstants: any = null;\n\n// Try to import expo-constants if we're in React Native\ntry {\n  expoConstants = require('expo-constants').default;\n} catch (e) {\n  // Not in React Native environment, will use process.env\n}\n\nexport function getEnv(key: string): string | undefined {\n  // React Native: use Expo Constants\n  if (expoConstants?.expoConfig?.extra) {\n    return expoConstants.expoConfig.extra[key];\n  }\n\n  // Node.js: use process.env\n  if (typeof process !== 'undefined' && process.env) {\n    return process.env[key];\n  }\n\n  return undefined;\n}\n\nexport function requireEnv(key: string): string {\n  const value = getEnv(key);\n  if (!value) {\n    throw new Error(`Required environment variable ${key} is not set`);\n  }\n  return value;\n}\n"],"names":[],"mappings":";;;;;;AAAA,gDAAgD;AAChD,wDAAwD;AAExD,IAAI,gBAAqB;AAEzB,wDAAwD;AACxD,IAAI;IACF,gBAAgB,gQAA0B,OAAO;AACnD,EAAE,OAAO,GAAG;AACV,wDAAwD;AAC1D;AAEO,SAAS,OAAO,GAAW;IAChC,mCAAmC;IACnC,IAAI,eAAe,YAAY,OAAO;QACpC,OAAO,cAAc,UAAU,CAAC,KAAK,CAAC,IAAI;IAC5C;IAEA,2BAA2B;IAC3B,IAAI,OAAO,YAAY,eAAe,QAAQ,GAAG,EAAE;QACjD,OAAO,QAAQ,GAAG,CAAC,IAAI;IACzB;IAEA,OAAO;AACT;AAEO,SAAS,WAAW,GAAW;IACpC,MAAM,QAAQ,OAAO;IACrB,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,IAAI,WAAW,CAAC;IACnE;IACA,OAAO;AACT"}},
    {"offset": {"line": 1110, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/utils/src/index.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\n/**\n * Gemini often returns JSON wrapped in ```json ... ``` or ``` ... ```.\n * Strip those before parsing.\n */\nexport function parseJsonFromGemini(raw: string): unknown {\n  const trimmed = raw.trim()\n  const codeBlock = trimmed.match(/```(?:json)?\\s*([\\s\\S]*?)```/)\n  const jsonStr = codeBlock ? codeBlock[1].trim() : trimmed\n  return JSON.parse(jsonStr)\n}\n\n/**\n * Convert a Date into a specific IANA timezone without mutating the original date.\n * Relies on Intl API (works in Node 18+ and modern browsers).\n */\nexport function toTimeZone(date: Date, timeZone: string): Date {\n  const iso = date.toLocaleString('en-US', { timeZone })\n  return new Date(iso)\n}\n\n/**\n * Normalize a fuzzy time phrase into a target Date using a fallback day and timezone.\n * This is a minimal heuristic; callers should still ask for user confirmation.\n */\nexport function normalizeFuzzyTime(\n  phrase: string,\n  now: Date,\n  timeZone: string\n): Date | null {\n  const lower = phrase.toLowerCase().trim()\n  const base = toTimeZone(now, timeZone)\n\n  if (['today', 'tonight'].includes(lower)) return base\n  if (lower === 'tomorrow') {\n    const d = new Date(base)\n    d.setDate(d.getDate() + 1)\n    return d\n  }\n  if (lower.match(/^in \\\\d+ (minutes|min)$/)) {\n    const mins = parseInt(lower.match(/\\\\d+/)?.[0] || '0', 10)\n    const d = new Date(base)\n    d.setMinutes(d.getMinutes() + mins)\n    return d\n  }\n  if (lower.match(/^in \\\\d+ (hours|hrs|hour)$/)) {\n    const hrs = parseInt(lower.match(/\\\\d+/)?.[0] || '0', 10)\n    const d = new Date(base)\n    d.setHours(d.getHours() + hrs)\n    return d\n  }\n  return null\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,sOAAO,EAAC,IAAA,gMAAI,EAAC;AACtB;AAMO,SAAS,oBAAoB,GAAW;IAC7C,MAAM,UAAU,IAAI,IAAI;IACxB,MAAM,YAAY,QAAQ,KAAK,CAAC;IAChC,MAAM,UAAU,YAAY,SAAS,CAAC,EAAE,CAAC,IAAI,KAAK;IAClD,OAAO,KAAK,KAAK,CAAC;AACpB;AAMO,SAAS,WAAW,IAAU,EAAE,QAAgB;IACrD,MAAM,MAAM,KAAK,cAAc,CAAC,SAAS;QAAE;IAAS;IACpD,OAAO,IAAI,KAAK;AAClB;AAMO,SAAS,mBACd,MAAc,EACd,GAAS,EACT,QAAgB;IAEhB,MAAM,QAAQ,OAAO,WAAW,GAAG,IAAI;IACvC,MAAM,OAAO,WAAW,KAAK;IAE7B,IAAI;QAAC;QAAS;KAAU,CAAC,QAAQ,CAAC,QAAQ,OAAO;IACjD,IAAI,UAAU,YAAY;QACxB,MAAM,IAAI,IAAI,KAAK;QACnB,EAAE,OAAO,CAAC,EAAE,OAAO,KAAK;QACxB,OAAO;IACT;IACA,IAAI,MAAM,KAAK,CAAC,4BAA4B;QAC1C,MAAM,OAAO,SAAS,MAAM,KAAK,CAAC,SAAS,CAAC,EAAE,IAAI,KAAK;QACvD,MAAM,IAAI,IAAI,KAAK;QACnB,EAAE,UAAU,CAAC,EAAE,UAAU,KAAK;QAC9B,OAAO;IACT;IACA,IAAI,MAAM,KAAK,CAAC,+BAA+B;QAC7C,MAAM,MAAM,SAAS,MAAM,KAAK,CAAC,SAAS,CAAC,EAAE,IAAI,KAAK;QACtD,MAAM,IAAI,IAAI,KAAK;QACnB,EAAE,QAAQ,CAAC,EAAE,QAAQ,KAAK;QAC1B,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 1169, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/gemini.ts"],"sourcesContent":["// Gemini AI service for agent operations\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { getEnv } from './env';\nimport { parseJsonFromGemini } from '@automation/utils';\n\n// This will be used for all Gemini API calls\nexport class GeminiService {\n  private apiKey: string;\n  private genAI: GoogleGenerativeAI | null = null;\n\n  constructor() {\n    this.apiKey = getEnv('GEMINI_API_KEY') || '';\n    \n    // Remove any surrounding quotes that might have been included\n    if (this.apiKey) {\n      this.apiKey = this.apiKey.trim().replace(/^[\"']|[\"']$/g, '');\n    }\n    \n    if (!this.apiKey) {\n      console.error('GEMINI_API_KEY is not set in environment variables');\n    } else {\n      console.log('Gemini API key loaded, length:', this.apiKey.length);\n      try {\n        this.genAI = new GoogleGenerativeAI(this.apiKey);\n      } catch (error) {\n        console.error('Failed to initialize Google Generative AI:', error);\n      }\n    }\n  }\n\n  async generateContent(prompt: string, modelName: string = 'gemini-2.0-flash'): Promise<string> {\n    if (!this.genAI) {\n      throw new Error('Google Generative AI not initialized. Check your API key.');\n    }\n\n    // Try multiple model names in order of preference (updated to use currently available models)\n    // Start with newer models that are actually available in v1beta API\n    const modelNames = [\n      'gemini-2.5-flash',  // Latest available\n      'gemini-2.0-flash',  // Known to work (confirmed from your logs)\n    ];\n\n    // Allow override via environment variable or parameter\n    const preferredModel = getEnv('GEMINI_MODEL') || modelName;\n    if (preferredModel && modelNames.includes(preferredModel)) {\n      modelNames.unshift(preferredModel);\n    }\n\n    let lastError: Error | null = null;\n    let attemptedModels: string[] = [];\n    \n    for (const model of modelNames) {\n      try {\n        const genModel = this.genAI.getGenerativeModel({ model });\n        const result = await genModel.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n        \n        // Silently succeed - no logging needed for normal operation\n        return text;\n      } catch (error: any) {\n        // Silently skip 404 errors (model not available) - these are expected when trying fallbacks\n        // Only track non-404 errors as they might indicate real problems\n        if (!error.message?.includes('404') && !error.message?.includes('Not Found')) {\n          console.warn(`Error with model ${model}:`, error.message);\n        }\n        attemptedModels.push(model);\n        lastError = error;\n        // Continue to next model\n        continue;\n      }\n    }\n\n    // If we get here, all models failed - log all attempted models\n    const errorMessage = `Failed to generate content with any available Gemini model. Attempted: ${attemptedModels.join(', ')}. Please check your API key and model availability.`;\n    console.error(errorMessage);\n    throw lastError || new Error(errorMessage);\n  }\n\n  generatePrompt(agentType: 'planner' | 'prioritization' | 'scheduler' | 'execution' | 'reflection', context: any): string {\n    switch (agentType) {\n      case 'planner':\n        return this.generatePlannerPrompt(context);\n      case 'prioritization':\n        return this.generatePrioritizationPrompt(context);\n      case 'scheduler':\n        return this.generateSchedulerPrompt(context);\n      case 'execution':\n        return this.generateExecutionPrompt(context);\n      case 'reflection':\n        return this.generateReflectionPrompt(context);\n      default:\n        throw new Error(`Unknown agent type: ${agentType}`);\n    }\n  }\n\n  private generatePlannerPrompt(context: any): string {\n    const memoryContext = context.memoryContext || {};\n    const similarItems = context.similarItems || [];\n    const originalInput = context.originalInput || context.goals.join(', ');\n    \n    let memorySection = '';\n    if (memoryContext.existingPlans && memoryContext.existingPlans.length > 0) {\n      memorySection += `\\n\\nExisting Plans (for context, avoid duplication):\\n${memoryContext.existingPlans.slice(0, 5).map((plan: any) => \n        `- \"${plan.title}\": ${plan.description} (Goal: ${plan.goal})`\n      ).join('\\n')}`;\n    }\n    \n    if (memoryContext.relatedTasks && memoryContext.relatedTasks.length > 0) {\n      memorySection += `\\n\\nRelated Tasks (for context):\\n${memoryContext.relatedTasks.slice(0, 5).map((task: any) => \n        `- \"${task.title}\": ${task.description || 'No description'}`\n      ).join('\\n')}`;\n    }\n    \n    let duplicateWarning = '';\n    if (similarItems.length > 0) {\n      duplicateWarning = `\\n\\n DUPLICATE DETECTION: Similar items found:\\n${similarItems.map((item: any) => \n        `- ${item.type === 'plan' ? 'Plan' : 'Task'}: \"${item.item.title}\" (${(item.similarity * 100).toFixed(0)}% similar) - ${item.reason}`\n      ).join('\\n')}\\n\\nIMPORTANT: If creating a new plan, ensure it's meaningfully different from the above. Consider merging or updating existing items instead.`;\n    }\n\n    return `You are a task planning AI assistant. Your job is to help users break down their goals into actionable tasks.\n\nUser Input: \"${originalInput}\"\nUser goals: ${context.goals.join(', ')}\nTime constraints: ${JSON.stringify(context.constraints)}\nExpected timeframe: ${context.timeframe ? `${context.timeframe.start} to ${context.timeframe.end}` : 'not specified'}${memorySection}${duplicateWarning}\n\nFIRST, generate a meaningful plan title and description from the user input:\n- Title: Should be concise (under 60 characters), descriptive, and capture the essence of the goal\n- Description: Should be a brief summary (under 200 characters) explaining what this plan aims to achieve\n\nTHEN, break down these goals into specific, actionable tasks. For each task, provide:\n1. A clear title (under 60 characters)\n2. A brief description (under 150 characters)\n3. Estimated time to complete (in minutes)\n4. Required focus level (shallow, medium, or deep)\n5. Energy requirement (low, medium, or high)\n6. Appropriate context (home, work, or anywhere)\n7. Relevant tags (max 3)\n8. kind: one of \"reminder\" (one-off time-based), \"todo\" (general actionable item), \"habit\" (recurring, no fixed time), \"daily\" (recurring daily)\n9. recurrencePerWeek: 1 for reminder/todo, 7 for daily, 3 for habit (times per week)\n\nReturn ONLY valid JSON. Do not wrap in markdown code blocks (no \\`\\`\\`).\nUse this structure:\n{\n  \"planTitle\": \"generated title from user input\",\n  \"planDescription\": \"generated description from user input\",\n  \"tasks\": [\n    {\n      \"title\": \"string\",\n      \"description\": \"string\",\n      \"estimatedTime\": number,\n      \"focusLevel\": \"shallow|medium|deep\",\n      \"energyRequirement\": \"low|medium|high\",\n      \"context\": \"home|work|anywhere\",\n      \"tags\": [\"tag1\", \"tag2\"],\n      \"kind\": \"reminder|todo|habit|daily\",\n      \"recurrencePerWeek\": number\n    }\n  ]\n}`;\n  }\n\n  private generatePrioritizationPrompt(context: any): string {\n    return `You are a task prioritization AI assistant. Your goal is to translate user priorities into a structured ranking while respecting temporal feasibility and human limitations.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Trust is preserved by predictability, not cleverness.\n- Explain your reasoning.\n\nCurrent Context:\n${context.currentContext ? `\n- Available time: ${context.currentContext.availableTime} minutes\n- Current energy level: ${context.currentContext.currentEnergy}\n- Current location: ${context.currentContext.location}\n- Available tools: ${context.currentContext.toolsAvailable.join(', ')}` : 'No specific context provided'}\n\nPlease analyze these tasks and rank them by priority. Consider:\n1. Deadline importance\n2. Long-term value\n3. Required focus level\n4. Energy cost\n5. Dependency complexity\n6. User preferences based on context\n\nTasks to prioritize:\n${JSON.stringify(context.tasks, null, 2)}\n\nReturn your response as JSON with an array of prioritized tasks and a brief summary of your reasoning:\n{\n  \"tasks\": [\n    {\n      \"id\": \"task_id\",\n      \"priorityScore\": number,\n      \"priority\": \"low|medium|high|urgent\",\n      \"reasoning\": \"brief explanation of priority score\"\n    }\n  ],\n  \"reasoning\": [\"point 1\", \"point 2\"]\n}`;\n  }\n\n  private generateSchedulerPrompt(context: any): string {\n    return `You are a task scheduling AI assistant. Your goal is to translate user goals into a realistic, temporally feasible schedule.\n\nPhilosophy:\n- Time is the governing dimension of the system.\n- Prefer fewer commitments and realistic schedules.\n- Always explain what you are about to do.\n- AI is a translator, not an authority.\n\nDate to schedule: ${context.date.toLocaleDateString()}\nEnergy profile: ${JSON.stringify(context.energyProfile)}\n${context.existingEvents ? `Existing events: ${JSON.stringify(context.existingEvents)}` : ''}\n${context.constraints ? `Constraints: ${JSON.stringify(context.constraints)}` : ''}\n\nTasks to schedule:\n${JSON.stringify(context.tasks, null, 2)}\n\nPlease create a Schedule for this date. Consider:\n1. User's energy profile (when their focus is strongest/weakest)\n2. Deep work session limits (max 2-3 sessions per day)\n3. Break time between deep work sessions (at least 15 minutes)\n4. Task focus levels and energy requirements\n5. Conflicts with existing events\n\nReturn your response as JSON with a schedule and reasoning:\n{\n  \"schedule\": {\n    \"date\": \"${context.date.toISOString()}\",\n    \"tasks\": [\n      {\n        \"taskId\": \"task_id\",\n        \"title\": \"task_title\",\n        \"scheduledStart\": \"ISO_datetime\",\n        \"scheduledEnd\": \"ISO_datetime\",\n        \"status\": \"scheduled\"\n      }\n    ],\n    \"reasoning\": [\"point 1\", \"point 2\"]\n  }\n}`;\n  }\n\n  private generateExecutionPrompt(context: any): string {\n    return `You are a task execution AI assistant. Your goal is to help users work on their current task by translating intent into concrete steps and identifying potential blockers.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Trust is preserved by predictability and clarity.\n- Reduce cognitive load by providing focused instructions.\n\nCurrent task: ${JSON.stringify(context.currentTask, null, 2)}\n${context.progress ? `Current progress: ${JSON.stringify(context.progress)}` : ''}\n${context.nextSteps ? `Next steps: ${context.nextSteps.join(', ')}` : ''}\n\nPlease provide:\n1. The absolute next step the user should take\n2. Clear instructions on how to complete this step\n3. Estimated time to complete this step\n4. Relevant context about related tasks and potential blockers\n5. Helpful suggestions for effective execution\n\nReturn your response as JSON:\n{\n  \"nextStep\": {\n    \"action\": \"string\",\n    \"instructions\": \"string\",\n    \"estimatedTime\": number,\n  },\n  \"context\": {\n    \"relatedTasks\": [\"task_id1\", \"task_id2\"],\n    \"blockers\": [\"blocker1\", \"blocker2\"],\n    \"resources\": [\"resource1\", \"resource2\"]\n  },\n  \"suggestions\": [\"suggestion1\", \"suggestion2\"]\n}`;\n  }\n\n  private generateReflectionPrompt(context: any): string {\n    return `You are a task reflection AI assistant. Your goal is to help users learn from their task completion patterns by providing non-authoritative advisory warnings and insights.\n\nPhilosophy:\n- Behavioral insights should be advisory, not authoritative.\n- Labels and warnings must be clear and skippable.\n- Focus on reducing cognitive load and increasing clarity.\n\nTasks being reflected on: ${JSON.stringify(context.tasks, null, 2)}\n${context.completionHistory.length > 0 ? `Task completion history: ${JSON.stringify(context.completionHistory, null, 2)}` : ''}\n${context.userFeedback && context.userFeedback.length > 0 ? `User feedback: ${JSON.stringify(context.userFeedback, null, 2)}` : ''}\n\nPlease analyze this data and provide:\n\n1. Behavioral patterns in task completion (time estimation accuracy, procrastination tendencies, etc.)\n2. Specific adjustments the user should make to their process\n3. Personalized recommendations for better task management\n\nReturn your response as JSON:\n{\n  \"insights\": {\n    \"patterns\": [\"pattern1\", \"pattern2\"],\n    \"adjustments\": [\n      {\n        \"type\": \"time|energy|priority|process\",\n        \"before\": \"current approach\",\n        \"after\": \"suggested approach\",\n        \"reason\": \"why this change would help\"\n      }\n    ]\n  },\n  \"recommendations\": [\"recommendation1\", \"recommendation2\"]\n}`;\n  }\n\n  async processVoiceTranscript(transcript: string, now: Date, timeZone: string) {\n    const prompt = `You are a voice-to-intent translator for a productivity system.\nYour goal is to split a messy voice transcript into logical chunks and classify each chunk.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Be conservative with intent detection.\n- Time is a first-class constraint. Normalize all time expressions relative to \"now\".\n\nCurrent \"Now\": ${now.toISOString()}\nCurrent Timezone: ${timeZone}\n\nTranscript: \"${transcript}\"\n\nSplit the transcript into logical chunks. For each chunk, determine:\n1. \"intent\": 'task' | 'reminder' | 'habit' | 'note' | 'unknown'\n2. \"normalized\": A cleaner version of the raw text.\n3. \"timeExpressions\": Array of normalized ISO-8601 timestamps found in the chunk, or relative time offsets.\n4. \"dueAt\": A single ISO-8601 timestamp representing the primary deadline or reminder time, if any.\n\nReturn your response as JSON with an array of chunks:\n{\n  \"chunks\": [\n    {\n      \"raw\": \"original segment\",\n      \"normalized\": \"clean version\",\n      \"intent\": \"task|reminder|habit|note|unknown\",\n      \"timeExpressions\": [\"ISO_timestamp\"],\n      \"dueAt\": \"ISO_timestamp or null\"\n    }\n  ]\n}`;\n\n    const response = await this.generateContent(prompt, 'gemini-1.5-flash');\n    try {\n      return parseJsonFromGemini(response);\n    } catch (error) {\n      console.error('Failed to parse Gemini response for voice transcript:', error);\n      return { chunks: [] };\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1511, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/memory-service.ts"],"sourcesContent":["import { taskRepo, planRepo, agentOutputRepo } from '@automation/data';\nimport { Task, Plan, AgentOutput } from '@automation/types';\nimport { GeminiService } from './gemini';\nimport { parseJsonFromGemini } from '@automation/utils';\n\nexport interface SimilarItem {\n  item: Task | Plan;\n  type: 'task' | 'plan';\n  similarity: number;\n  reason: string;\n}\n\nexport interface UserContext {\n  recentOutputs: AgentOutput[];\n  existingPlans: Plan[];\n  existingTasks: Task[];\n  recentInputs: string[];\n}\n\nexport class MemoryService {\n  private geminiService: GeminiService;\n\n  constructor() {\n    this.geminiService = new GeminiService();\n  }\n\n  /**\n   * Get comprehensive user context for memory-aware processing\n   */\n  async getUserContext(userId: string): Promise<UserContext> {\n    const [allPlans, allTasks, allOutputs] = await Promise.all([\n      planRepo.getAll(),\n      taskRepo.getAll(),\n      agentOutputRepo.getAll(),\n    ]);\n\n    // Filter to user's data (for now, we'll use all data since we don't have user filtering yet)\n    const userPlans = allPlans;\n    const userTasks = allTasks;\n    \n    // Get last 50 agent outputs (most recent first)\n    const recentOutputs = allOutputs\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n      .slice(0, 50);\n\n    // Extract recent user inputs from agent outputs\n    const recentInputs = recentOutputs\n      .map(output => {\n        if (output.input?.goals) {\n          return Array.isArray(output.input.goals) \n            ? output.input.goals.join(' ') \n            : output.input.goals;\n        }\n        if (output.input?.message) {\n          return output.input.message;\n        }\n        return null;\n      })\n      .filter((input): input is string => input !== null)\n      .slice(0, 20);\n\n    return {\n      recentOutputs,\n      existingPlans: userPlans,\n      existingTasks: userTasks,\n      recentInputs,\n    };\n  }\n\n  /**\n   * Find similar/duplicate items using semantic similarity\n   */\n  async findSimilarItems(\n    input: string,\n    userId: string,\n    threshold: number = 0.7\n  ): Promise<SimilarItem[]> {\n    const context = await this.getUserContext(userId);\n    const similarItems: SimilarItem[] = [];\n\n    // Use Gemini to analyze similarity\n    const prompt = `Analyze the following user input and compare it with existing plans and tasks to find duplicates or very similar items.\n\nUser Input: \"${input}\"\n\nExisting Plans:\n${context.existingPlans.map(plan => `- ID: ${plan.id}, Title: \"${plan.title}\", Description: \"${plan.description}\", Goal: \"${plan.goal}\"`).join('\\n')}\n\nExisting Tasks:\n${context.existingTasks.map(task => `- ID: ${task.id}, Title: \"${task.title}\", Description: \"${task.description || ''}\"`).join('\\n')}\n\nFor each existing item, determine:\n1. Similarity score (0-1, where 1 is identical/duplicate, 0.7+ is very similar)\n2. Reason for similarity\n\nReturn JSON array with format:\n{\n  \"similarItems\": [\n    {\n      \"id\": \"item_id\",\n      \"type\": \"plan\" or \"task\",\n      \"similarity\": 0.0-1.0,\n      \"reason\": \"brief explanation\"\n    }\n  ]\n}\n\nOnly include items with similarity >= ${threshold}.`;\n\n    try {\n      const response = await this.geminiService.generateContent(prompt);\n      const result = parseJsonFromGemini(response) as { similarItems?: Array<{ id: string; type: 'plan' | 'task'; similarity: number; reason?: string }> };\n      \n      if (result.similarItems && Array.isArray(result.similarItems)) {\n        for (const item of result.similarItems) {\n          const existingItem = item.type === 'plan'\n            ? context.existingPlans.find(p => p.id === item.id)\n            : context.existingTasks.find(t => t.id === item.id);\n          \n          if (existingItem && item.similarity >= threshold) {\n            similarItems.push({\n              item: existingItem,\n              type: item.type,\n              similarity: item.similarity,\n              reason: item.reason || 'Similar content found',\n            });\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error finding similar items:', error);\n      // Fallback to simple text matching\n      return this.fallbackSimilarityCheck(input, context, threshold);\n    }\n\n    // Sort by similarity (highest first)\n    return similarItems.sort((a, b) => b.similarity - a.similarity);\n  }\n\n  /**\n   * Fallback similarity check using simple text matching\n   */\n  private fallbackSimilarityCheck(\n    input: string,\n    context: UserContext,\n    threshold: number\n  ): SimilarItem[] {\n    const similarItems: SimilarItem[] = [];\n    const inputLower = input.toLowerCase();\n    const inputWords = inputLower.split(/\\s+/);\n\n    // Check plans\n    for (const plan of context.existingPlans) {\n      const planText = `${plan.title} ${plan.description} ${plan.goal}`.toLowerCase();\n      const planWords = planText.split(/\\s+/);\n      \n      // Calculate simple word overlap\n      const commonWords = inputWords.filter(word => \n        word.length > 3 && planWords.includes(word)\n      );\n      const similarity = commonWords.length / Math.max(inputWords.length, planWords.length);\n      \n      if (similarity >= threshold) {\n        similarItems.push({\n          item: plan,\n          type: 'plan',\n          similarity,\n          reason: `Shared ${commonWords.length} keywords: ${commonWords.slice(0, 3).join(', ')}`,\n        });\n      }\n    }\n\n    // Check tasks\n    for (const task of context.existingTasks) {\n      const taskText = `${task.title} ${task.description || ''}`.toLowerCase();\n      const taskWords = taskText.split(/\\s+/);\n      \n      const commonWords = inputWords.filter(word => \n        word.length > 3 && taskWords.includes(word)\n      );\n      const similarity = commonWords.length / Math.max(inputWords.length, taskWords.length);\n      \n      if (similarity >= threshold) {\n        similarItems.push({\n          item: task,\n          type: 'task',\n          similarity,\n          reason: `Shared ${commonWords.length} keywords: ${commonWords.slice(0, 3).join(', ')}`,\n        });\n      }\n    }\n\n    return similarItems;\n  }\n\n  /**\n   * Get contextually related items for enriching AI prompts\n   */\n  async getRelatedContext(\n    input: string,\n    userId: string\n  ): Promise<{\n    relatedPlans: Plan[];\n    relatedTasks: Task[];\n    relatedTags: string[];\n  }> {\n    const context = await this.getUserContext(userId);\n    const inputLower = input.toLowerCase();\n    const inputWords = inputLower.split(/\\s+/).filter(w => w.length > 3);\n\n    // Find plans with similar goals/tags\n    const relatedPlans = context.existingPlans.filter(plan => {\n      const planText = `${plan.title} ${plan.description} ${plan.goal}`.toLowerCase();\n      return inputWords.some(word => planText.includes(word));\n    });\n\n    // Find tasks with similar descriptions/tags\n    const relatedTasks = context.existingTasks.filter(task => {\n      const taskText = `${task.title} ${task.description || ''} ${task.tags.join(' ')}`.toLowerCase();\n      return inputWords.some(word => taskText.includes(word));\n    });\n\n    // Extract common tags\n    const allTags = new Set<string>();\n    relatedPlans.forEach(plan => {\n      // Plans don't have tags in the model, but we can extract from related tasks\n    });\n    relatedTasks.forEach(task => {\n      task.tags.forEach(tag => allTags.add(tag));\n    });\n\n    return {\n      relatedPlans: relatedPlans.slice(0, 5), // Limit to top 5\n      relatedTasks: relatedTasks.slice(0, 10), // Limit to top 10\n      relatedTags: Array.from(allTags).slice(0, 10),\n    };\n  }\n}\n\nexport const memoryService = new MemoryService();\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAEA;AACA;;;;AAgBO,MAAM;IACH,cAA6B;IAErC,aAAc;QACZ,IAAI,CAAC,aAAa,GAAG,IAAI,wJAAa;IACxC;IAEA;;GAEC,GACD,MAAM,eAAe,MAAc,EAAwB;QACzD,MAAM,CAAC,UAAU,UAAU,WAAW,GAAG,MAAM,QAAQ,GAAG,CAAC;YACzD,qJAAQ,CAAC,MAAM;YACf,qJAAQ,CAAC,MAAM;YACf,4JAAe,CAAC,MAAM;SACvB;QAED,6FAA6F;QAC7F,MAAM,YAAY;QAClB,MAAM,YAAY;QAElB,gDAAgD;QAChD,MAAM,gBAAgB,WACnB,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO,IAC9E,KAAK,CAAC,GAAG;QAEZ,gDAAgD;QAChD,MAAM,eAAe,cAClB,GAAG,CAAC,CAAA;YACH,IAAI,OAAO,KAAK,EAAE,OAAO;gBACvB,OAAO,MAAM,OAAO,CAAC,OAAO,KAAK,CAAC,KAAK,IACnC,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,OACxB,OAAO,KAAK,CAAC,KAAK;YACxB;YACA,IAAI,OAAO,KAAK,EAAE,SAAS;gBACzB,OAAO,OAAO,KAAK,CAAC,OAAO;YAC7B;YACA,OAAO;QACT,GACC,MAAM,CAAC,CAAC,QAA2B,UAAU,MAC7C,KAAK,CAAC,GAAG;QAEZ,OAAO;YACL;YACA,eAAe;YACf,eAAe;YACf;QACF;IACF;IAEA;;GAEC,GACD,MAAM,iBACJ,KAAa,EACb,MAAc,EACd,YAAoB,GAAG,EACC;QACxB,MAAM,UAAU,MAAM,IAAI,CAAC,cAAc,CAAC;QAC1C,MAAM,eAA8B,EAAE;QAEtC,mCAAmC;QACnC,MAAM,SAAS,CAAC;;aAEP,EAAE,MAAM;;;AAGrB,EAAE,QAAQ,aAAa,CAAC,GAAG,CAAC,CAAA,OAAQ,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,UAAU,EAAE,KAAK,KAAK,CAAC,iBAAiB,EAAE,KAAK,WAAW,CAAC,UAAU,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM;;;AAGrJ,EAAE,QAAQ,aAAa,CAAC,GAAG,CAAC,CAAA,OAAQ,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,UAAU,EAAE,KAAK,KAAK,CAAC,iBAAiB,EAAE,KAAK,WAAW,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM;;;;;;;;;;;;;;;;;;sCAkB/F,EAAE,UAAU,CAAC,CAAC;QAEhD,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC;YAC1D,MAAM,SAAS,IAAA,0JAAmB,EAAC;YAEnC,IAAI,OAAO,YAAY,IAAI,MAAM,OAAO,CAAC,OAAO,YAAY,GAAG;gBAC7D,KAAK,MAAM,QAAQ,OAAO,YAAY,CAAE;oBACtC,MAAM,eAAe,KAAK,IAAI,KAAK,SAC/B,QAAQ,aAAa,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE,IAChD,QAAQ,aAAa,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE;oBAEpD,IAAI,gBAAgB,KAAK,UAAU,IAAI,WAAW;wBAChD,aAAa,IAAI,CAAC;4BAChB,MAAM;4BACN,MAAM,KAAK,IAAI;4BACf,YAAY,KAAK,UAAU;4BAC3B,QAAQ,KAAK,MAAM,IAAI;wBACzB;oBACF;gBACF;YACF;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,mCAAmC;YACnC,OAAO,IAAI,CAAC,uBAAuB,CAAC,OAAO,SAAS;QACtD;QAEA,qCAAqC;QACrC,OAAO,aAAa,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,UAAU,GAAG,EAAE,UAAU;IAChE;IAEA;;GAEC,GACD,AAAQ,wBACN,KAAa,EACb,OAAoB,EACpB,SAAiB,EACF;QACf,MAAM,eAA8B,EAAE;QACtC,MAAM,aAAa,MAAM,WAAW;QACpC,MAAM,aAAa,WAAW,KAAK,CAAC;QAEpC,cAAc;QACd,KAAK,MAAM,QAAQ,QAAQ,aAAa,CAAE;YACxC,MAAM,WAAW,GAAG,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,WAAW,CAAC,CAAC,EAAE,KAAK,IAAI,EAAE,CAAC,WAAW;YAC7E,MAAM,YAAY,SAAS,KAAK,CAAC;YAEjC,gCAAgC;YAChC,MAAM,cAAc,WAAW,MAAM,CAAC,CAAA,OACpC,KAAK,MAAM,GAAG,KAAK,UAAU,QAAQ,CAAC;YAExC,MAAM,aAAa,YAAY,MAAM,GAAG,KAAK,GAAG,CAAC,WAAW,MAAM,EAAE,UAAU,MAAM;YAEpF,IAAI,cAAc,WAAW;gBAC3B,aAAa,IAAI,CAAC;oBAChB,MAAM;oBACN,MAAM;oBACN;oBACA,QAAQ,CAAC,OAAO,EAAE,YAAY,MAAM,CAAC,WAAW,EAAE,YAAY,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO;gBACxF;YACF;QACF;QAEA,cAAc;QACd,KAAK,MAAM,QAAQ,QAAQ,aAAa,CAAE;YACxC,MAAM,WAAW,GAAG,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,WAAW,IAAI,IAAI,CAAC,WAAW;YACtE,MAAM,YAAY,SAAS,KAAK,CAAC;YAEjC,MAAM,cAAc,WAAW,MAAM,CAAC,CAAA,OACpC,KAAK,MAAM,GAAG,KAAK,UAAU,QAAQ,CAAC;YAExC,MAAM,aAAa,YAAY,MAAM,GAAG,KAAK,GAAG,CAAC,WAAW,MAAM,EAAE,UAAU,MAAM;YAEpF,IAAI,cAAc,WAAW;gBAC3B,aAAa,IAAI,CAAC;oBAChB,MAAM;oBACN,MAAM;oBACN;oBACA,QAAQ,CAAC,OAAO,EAAE,YAAY,MAAM,CAAC,WAAW,EAAE,YAAY,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO;gBACxF;YACF;QACF;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,kBACJ,KAAa,EACb,MAAc,EAKb;QACD,MAAM,UAAU,MAAM,IAAI,CAAC,cAAc,CAAC;QAC1C,MAAM,aAAa,MAAM,WAAW;QACpC,MAAM,aAAa,WAAW,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,IAAK,EAAE,MAAM,GAAG;QAElE,qCAAqC;QACrC,MAAM,eAAe,QAAQ,aAAa,CAAC,MAAM,CAAC,CAAA;YAChD,MAAM,WAAW,GAAG,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,WAAW,CAAC,CAAC,EAAE,KAAK,IAAI,EAAE,CAAC,WAAW;YAC7E,OAAO,WAAW,IAAI,CAAC,CAAA,OAAQ,SAAS,QAAQ,CAAC;QACnD;QAEA,4CAA4C;QAC5C,MAAM,eAAe,QAAQ,aAAa,CAAC,MAAM,CAAC,CAAA;YAChD,MAAM,WAAW,GAAG,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,WAAW,IAAI,GAAG,CAAC,EAAE,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW;YAC7F,OAAO,WAAW,IAAI,CAAC,CAAA,OAAQ,SAAS,QAAQ,CAAC;QACnD;QAEA,sBAAsB;QACtB,MAAM,UAAU,IAAI;QACpB,aAAa,OAAO,CAAC,CAAA;QACnB,4EAA4E;QAC9E;QACA,aAAa,OAAO,CAAC,CAAA;YACnB,KAAK,IAAI,CAAC,OAAO,CAAC,CAAA,MAAO,QAAQ,GAAG,CAAC;QACvC;QAEA,OAAO;YACL,cAAc,aAAa,KAAK,CAAC,GAAG;YACpC,cAAc,aAAa,KAAK,CAAC,GAAG;YACpC,aAAa,MAAM,IAAI,CAAC,SAAS,KAAK,CAAC,GAAG;QAC5C;IACF;AACF;AAEO,MAAM,gBAAgB,IAAI"}},
    {"offset": {"line": 1691, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/pressure-service.ts"],"sourcesContent":["import type { Task, Project, TaskKind } from \"@automation/types\";\n\nconst KINDS: TaskKind[] = [\"reminder\", \"todo\", \"habit\", \"daily\"];\n\nfunction defaultRecurrencePerWeek(kind: TaskKind): number {\n  switch (kind) {\n    case \"daily\":\n      return 7;\n    case \"habit\":\n      return 3;\n    case \"reminder\":\n    case \"todo\":\n    default:\n      return 1;\n  }\n}\n\n/** Current ISO week (MonSun) bounds. */\nexport function getWeekBounds(): { start: Date; end: Date } {\n  const now = new Date();\n  const day = now.getDay();\n  const diff = now.getDate() - day + (day === 0 ? -6 : 1);\n  const start = new Date(now);\n  start.setDate(diff);\n  start.setHours(0, 0, 0, 0);\n  const end = new Date(start);\n  end.setDate(start.getDate() + 6);\n  end.setHours(23, 59, 59, 999);\n  return { start, end };\n}\n\nfunction inWeek(d: Date, start: Date, end: Date): boolean {\n  const t = new Date(d).getTime();\n  return t >= start.getTime() && t <= end.getTime();\n}\n\nexport interface PressureResult {\n  totalHours: number;\n  projectHours: number;\n  nonProjectHours: number;\n  itemCount: number;\n  /** Non-project tasks + projects. Higher = more fragmented. */\n  fragmentation: \"low\" | \"medium\" | \"high\";\n  byKind: Record<TaskKind, { count: number; hours: number }>;\n  projects: { id: string; title: string; weeklyHours: number }[];\n}\n\n/**\n * Compute weekly pressure: hours from non-project tasks (reminder, todo, habit, daily)\n * plus project weekly allocations. Tasks in projects don't add timeproject hours count.\n * More hours + more split (items) = harder.\n */\nexport function computePressure(tasks: Task[], projects: Project[]): PressureResult {\n  const { start, end } = getWeekBounds();\n  const byKind: Record<TaskKind, { count: number; hours: number }> = {\n    reminder: { count: 0, hours: 0 },\n    todo: { count: 0, hours: 0 },\n    habit: { count: 0, hours: 0 },\n    daily: { count: 0, hours: 0 },\n  };\n\n  let nonProjectMinutes = 0;\n  let nonProjectItemCount = 0;\n\n  for (const t of tasks) {\n    if (t.status === \"cancelled\") continue;\n    const kind = (t.kind ?? \"todo\") as TaskKind;\n    if (!KINDS.includes(kind)) continue;\n    if (t.projectId) continue;\n\n    const perWeek = t.recurrencePerWeek ?? defaultRecurrencePerWeek(kind);\n    const minutes = t.estimatedTime * perWeek;\n    byKind[kind].hours += minutes / 60;\n    byKind[kind].count += 1;\n    nonProjectMinutes += minutes;\n    nonProjectItemCount += 1;\n  }\n\n  let projectHours = 0;\n  for (const p of projects) {\n    projectHours += p.weeklyHours;\n  }\n\n  const nonProjectHours = nonProjectMinutes / 60;\n  const totalHours = nonProjectHours + projectHours;\n  const itemCount = nonProjectItemCount + projects.length;\n\n  let fragmentation: \"low\" | \"medium\" | \"high\" = \"low\";\n  if (totalHours > 0) {\n    const itemsPer10h = itemCount / (totalHours / 10);\n    if (itemsPer10h >= 8 || itemCount >= 25) fragmentation = \"high\";\n    else if (itemsPer10h >= 4 || itemCount >= 12) fragmentation = \"medium\";\n  }\n\n  return {\n    totalHours,\n    projectHours,\n    nonProjectHours,\n    itemCount,\n    fragmentation,\n    byKind,\n    projects: projects.map((p) => ({ id: p.id, title: p.title, weeklyHours: p.weeklyHours })),\n  };\n}\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,QAAoB;IAAC;IAAY;IAAQ;IAAS;CAAQ;AAEhE,SAAS,yBAAyB,IAAc;IAC9C,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;QACL;YACE,OAAO;IACX;AACF;AAGO,SAAS;IACd,MAAM,MAAM,IAAI;IAChB,MAAM,MAAM,IAAI,MAAM;IACtB,MAAM,OAAO,IAAI,OAAO,KAAK,MAAM,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC;IACtD,MAAM,QAAQ,IAAI,KAAK;IACvB,MAAM,OAAO,CAAC;IACd,MAAM,QAAQ,CAAC,GAAG,GAAG,GAAG;IACxB,MAAM,MAAM,IAAI,KAAK;IACrB,IAAI,OAAO,CAAC,MAAM,OAAO,KAAK;IAC9B,IAAI,QAAQ,CAAC,IAAI,IAAI,IAAI;IACzB,OAAO;QAAE;QAAO;IAAI;AACtB;AAEA,SAAS,OAAO,CAAO,EAAE,KAAW,EAAE,GAAS;IAC7C,MAAM,IAAI,IAAI,KAAK,GAAG,OAAO;IAC7B,OAAO,KAAK,MAAM,OAAO,MAAM,KAAK,IAAI,OAAO;AACjD;AAkBO,SAAS,gBAAgB,KAAa,EAAE,QAAmB;IAChE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG;IACvB,MAAM,SAA6D;QACjE,UAAU;YAAE,OAAO;YAAG,OAAO;QAAE;QAC/B,MAAM;YAAE,OAAO;YAAG,OAAO;QAAE;QAC3B,OAAO;YAAE,OAAO;YAAG,OAAO;QAAE;QAC5B,OAAO;YAAE,OAAO;YAAG,OAAO;QAAE;IAC9B;IAEA,IAAI,oBAAoB;IACxB,IAAI,sBAAsB;IAE1B,KAAK,MAAM,KAAK,MAAO;QACrB,IAAI,EAAE,MAAM,KAAK,aAAa;QAC9B,MAAM,OAAQ,EAAE,IAAI,IAAI;QACxB,IAAI,CAAC,MAAM,QAAQ,CAAC,OAAO;QAC3B,IAAI,EAAE,SAAS,EAAE;QAEjB,MAAM,UAAU,EAAE,iBAAiB,IAAI,yBAAyB;QAChE,MAAM,UAAU,EAAE,aAAa,GAAG;QAClC,MAAM,CAAC,KAAK,CAAC,KAAK,IAAI,UAAU;QAChC,MAAM,CAAC,KAAK,CAAC,KAAK,IAAI;QACtB,qBAAqB;QACrB,uBAAuB;IACzB;IAEA,IAAI,eAAe;IACnB,KAAK,MAAM,KAAK,SAAU;QACxB,gBAAgB,EAAE,WAAW;IAC/B;IAEA,MAAM,kBAAkB,oBAAoB;IAC5C,MAAM,aAAa,kBAAkB;IACrC,MAAM,YAAY,sBAAsB,SAAS,MAAM;IAEvD,IAAI,gBAA2C;IAC/C,IAAI,aAAa,GAAG;QAClB,MAAM,cAAc,YAAY,CAAC,aAAa,EAAE;QAChD,IAAI,eAAe,KAAK,aAAa,IAAI,gBAAgB;aACpD,IAAI,eAAe,KAAK,aAAa,IAAI,gBAAgB;IAChE;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA,UAAU,SAAS,GAAG,CAAC,CAAC,IAAM,CAAC;gBAAE,IAAI,EAAE,EAAE;gBAAE,OAAO,EAAE,KAAK;gBAAE,aAAa,EAAE,WAAW;YAAC,CAAC;IACzF;AACF"}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/validation-service.ts"],"sourcesContent":["import { differenceInMinutes, isAfter, isBefore, format } from 'date-fns';\nimport {\n  ScheduledTask,\n  Task,\n  TimeBlock,\n  User,\n  ValidationIssue,\n  ValidationResult,\n  Project,\n} from '@automation/types';\nimport { computePressure } from './pressure-service';\n\ntype ScheduledLike = ScheduledTask | TimeBlock;\n\nexport class ValidationService {\n  /**\n   * Validate a proposed schedule before persistence.\n   * Returns blocking errors, warnings, and a human-friendly summary.\n   */\n  validateSchedule(params: {\n    tasks: Task[];\n    scheduled: ScheduledTask[];\n    events?: TimeBlock[];\n    user?: User;\n    date?: Date;\n  }): ValidationResult {\n    const issues: ValidationIssue[] = [];\n    const events = params.events ?? [];\n    const user = params.user;\n\n    // Hard conflicts: overlap between scheduled tasks and existing events\n    for (const taskBlock of params.scheduled) {\n      const conflict = events.find((evt) =>\n        this.overlaps(taskBlock, evt)\n      );\n      if (conflict) {\n        issues.push({\n          code: 'hard_conflict',\n          severity: 'error',\n          message: `Task ${taskBlock.taskId} overlaps ${conflict.type} (${this.rangeLabel(conflict)})`,\n          relatedIds: [taskBlock.taskId],\n          details: 'Hard overlap detected',\n        });\n      }\n    }\n\n    // Hard conflicts: overlapping scheduled tasks\n    const sorted = [...params.scheduled].sort(\n      (a, b) => a.scheduledStart.getTime() - b.scheduledStart.getTime()\n    );\n    for (let i = 0; i < sorted.length - 1; i++) {\n      if (this.overlaps(sorted[i], sorted[i + 1])) {\n        issues.push({\n          code: 'task_overlap',\n          severity: 'error',\n          message: `Tasks ${sorted[i].taskId} and ${sorted[i + 1].taskId} overlap (${this.rangeLabel(sorted[i])})`,\n          relatedIds: [sorted[i].taskId, sorted[i + 1].taskId],\n        });\n      }\n    }\n\n    // Semantic conflicts: deep work late night or beyond workday\n    for (const block of params.scheduled) {\n      const task = params.tasks.find((t) => t.id === block.taskId);\n      if (!task) continue;\n\n      const hour = block.scheduledStart.getHours();\n      if (task.focusLevel === 'deep' && (hour < 8 || hour >= 18)) {\n        issues.push({\n          code: 'semantic_energy_mismatch',\n          severity: 'warn',\n          message: `Deep work task \"${task.title}\" is scheduled outside typical focus hours`,\n          relatedIds: [task.id],\n        });\n      }\n\n      // Unrealistic duration check\n      const duration = differenceInMinutes(block.scheduledEnd, block.scheduledStart);\n      if (duration > 240) {\n        issues.push({\n          code: 'duration_exceeds_4h',\n          severity: 'warn',\n          message: `Task \"${task.title}\" is scheduled for ${duration} minutes; recommend splitting`,\n          relatedIds: [task.id],\n        });\n      }\n    }\n\n    // Cognitive load: total scheduled minutes vs. work window\n    const totalMinutes = params.scheduled.reduce(\n      (sum, t) => sum + differenceInMinutes(t.scheduledEnd, t.scheduledStart),\n      0\n    );\n    const workWindowMinutes = 8 * 60;\n    if (totalMinutes > workWindowMinutes) {\n      issues.push({\n        code: 'cognitive_overload',\n        severity: 'warn',\n        message: `Total scheduled time (${totalMinutes}m) exceeds standard work window (${workWindowMinutes}m).`,\n      });\n    }\n\n    // Physical feasibility: travel time/transition time (Semantic)\n    for (let i = 0; i < sorted.length - 1; i++) {\n      const first = sorted[i];\n      const second = sorted[i + 1];\n      const gap = differenceInMinutes(second.scheduledStart, first.scheduledEnd);\n      \n      if (gap < 5 && gap >= 0) {\n        issues.push({\n          code: 'insufficient_transition',\n          severity: 'warn',\n          message: `Back-to-back tasks without transition time: ${this.rangeLabel(first)} and ${this.rangeLabel(second)}`,\n          relatedIds: [first.taskId, second.taskId],\n        });\n      }\n\n      // Check for location changes (if location is available in metadata or context)\n      if (first.location && second.location && first.location !== second.location && gap < 30) {\n        issues.push({\n          code: 'location_conflict_travel',\n          severity: 'warn',\n          message: `Infeasible travel time between ${first.location} and ${second.location} (${gap}m gap)`,\n          relatedIds: [first.taskId, second.taskId],\n        });\n      }\n    }\n\n    // Time sanity: start before end\n    for (const block of params.scheduled) {\n      if (!isBefore(block.scheduledStart, block.scheduledEnd)) {\n        issues.push({\n          code: 'invalid_time_range',\n          severity: 'error',\n          message: `Task ${block.taskId} has an invalid time range`,\n          relatedIds: [block.taskId],\n        });\n      }\n    }\n\n    const blocking = issues.some((i) => i.severity === 'error');\n    const requiresConfirmation = issues.length > 0;\n\n    return {\n      ok: !blocking,\n      requiresConfirmation,\n      issues,\n      summary: this.buildSummary(issues, user),\n    };\n  }\n\n  /**\n   * Validate task input before creation/update.\n   * Enforces time presence, duration sanity, and dependency sanity.\n   */\n  validateTaskInput(params: {\n    task: Partial<Task>;\n    existing?: Task[];\n    projects?: Project[];\n  }): ValidationResult {\n    const { task, existing = [], projects = [] } = params;\n    const issues: ValidationIssue[] = [];\n\n    // Time is required for actionable items (todo/reminder). Habits/dailies can rely on recurrence.\n    const kind = task.kind ?? 'todo';\n    if (!task.dueDate && kind !== 'habit' && kind !== 'daily') {\n      issues.push({\n        code: 'time_missing',\n        severity: 'error',\n        message: 'A concrete time (due date or schedule) is required before committing the task.',\n      });\n    }\n\n    // Weekly Pressure Check\n    if (existing.length > 0) {\n      const currentPressure = computePressure(existing as Task[], projects);\n      if (currentPressure.totalHours > 40) {\n        issues.push({\n          code: 'weekly_overload',\n          severity: 'warn',\n          message: `Weekly workload is high (${currentPressure.totalHours.toFixed(1)}h). Consider deferring this task.`,\n        });\n      }\n    }\n\n    // Estimated time sanity\n    if (typeof task.estimatedTime === 'number' && task.estimatedTime <= 0) {\n      issues.push({\n        code: 'invalid_estimate',\n        severity: 'error',\n        message: 'Estimated time must be greater than zero minutes.',\n      });\n    }\n    if (typeof task.estimatedTime === 'number' && task.estimatedTime > 480) {\n      issues.push({\n        code: 'estimate_exceeds_day',\n        severity: 'warn',\n        message: 'Estimated time exceeds a full workday; consider splitting the task.',\n      });\n    }\n\n    // Dependency sanity\n    if (task.dependencies && task.dependencies.length) {\n      const missing = task.dependencies.filter(\n        (dep) => !existing.find((t) => t.id === dep)\n      );\n      if (missing.length) {\n        issues.push({\n          code: 'dependency_missing',\n          severity: 'error',\n          message: `Dependencies not found: ${missing.join(', ')}`,\n          relatedIds: missing,\n        });\n      }\n    }\n\n    return {\n      ok: !issues.some((i) => i.severity === 'error'),\n      requiresConfirmation: issues.length > 0,\n      issues,\n      summary: this.buildSummary(issues),\n    };\n  }\n\n  private overlaps(a: ScheduledLike, b: ScheduledLike): boolean {\n    const startA = 'scheduledStart' in a ? a.scheduledStart : a.start;\n    const endA = 'scheduledEnd' in a ? a.scheduledEnd : a.end;\n    const startB = 'scheduledStart' in b ? b.scheduledStart : b.start;\n    const endB = 'scheduledEnd' in b ? b.scheduledEnd : b.end;\n    return isBefore(startA, endB) && isAfter(endA, startB);\n  }\n\n  private buildSummary(issues: ValidationIssue[], user?: User): string[] {\n    if (!issues.length) return ['Validation passed  no conflicts detected'];\n    const blocking = issues.filter((i) => i.severity === 'error').length;\n    const warnings = issues.filter((i) => i.severity === 'warn').length;\n\n    const summary: string[] = [\n      `${blocking} blocking issue(s), ${warnings} warning(s) detected`,\n    ];\n\n    const top = issues.slice(0, 5).map((i) => `${i.severity.toUpperCase()}: ${i.message}`);\n    summary.push(...top);\n\n    if (user?.preferences?.notificationSettings?.scheduleChanges) {\n      summary.push('User notifications enabled: schedule changes should be summarized before send.');\n    }\n\n    return summary;\n  }\n\n  private rangeLabel(block: ScheduledLike): string {\n    const start = 'scheduledStart' in block ? block.scheduledStart : block.start;\n    const end = 'scheduledEnd' in block ? block.scheduledEnd : block.end;\n    return `${start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}${end.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;\n  }\n}\n\nexport const validationService = new ValidationService();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2040, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/notification-guard.ts"],"sourcesContent":["import { differenceInMinutes } from 'date-fns';\n\ninterface NotificationPayload {\n  title: string;\n  body: string;\n  data?: Record<string, string>;\n  priority?: 'normal' | 'high';\n}\n\ninterface NotificationContext {\n  lastSentAt?: Date;\n  minIntervalMinutes?: number;\n  channel?: 'task' | 'schedule' | 'summary' | 'system';\n}\n\nexport class NotificationGuard {\n  /**\n   * Validate and annotate a push notification before sending.\n   * Enforces explicit, meaningful, non-spammy rules from App_system.\n   */\n  validate(payload: NotificationPayload, ctx: NotificationContext = {}) {\n    const issues: string[] = [];\n\n    if (!payload.title || !payload.body) {\n      issues.push('Notification must include title and body.');\n    }\n\n    // Semantic quality checks\n    if (payload.body.length < 8) {\n      issues.push('Notification body is too short to be meaningful.');\n    }\n\n    // Rate limiting\n    const minInterval = ctx.minIntervalMinutes ?? 15;\n    if (ctx.lastSentAt) {\n      const minutesSinceLast = differenceInMinutes(new Date(), ctx.lastSentAt);\n      if (minutesSinceLast < minInterval) {\n        issues.push(`Last notification sent ${minutesSinceLast}m ago; wait at least ${minInterval}m to avoid spam.`);\n      }\n    }\n\n    return {\n      ok: issues.length === 0,\n      issues,\n      recommendation: 'Send only after user-visible confirmation for high-priority or back-to-back messages.',\n    };\n  }\n}\n\nexport const notificationGuard = new NotificationGuard();\n"],"names":[],"mappings":";;;;;;AAAA;;AAeO,MAAM;IACX;;;GAGC,GACD,SAAS,OAA4B,EAAE,MAA2B,CAAC,CAAC,EAAE;QACpE,MAAM,SAAmB,EAAE;QAE3B,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,IAAI,EAAE;YACnC,OAAO,IAAI,CAAC;QACd;QAEA,0BAA0B;QAC1B,IAAI,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG;YAC3B,OAAO,IAAI,CAAC;QACd;QAEA,gBAAgB;QAChB,MAAM,cAAc,IAAI,kBAAkB,IAAI;QAC9C,IAAI,IAAI,UAAU,EAAE;YAClB,MAAM,mBAAmB,IAAA,oOAAmB,EAAC,IAAI,QAAQ,IAAI,UAAU;YACvE,IAAI,mBAAmB,aAAa;gBAClC,OAAO,IAAI,CAAC,CAAC,uBAAuB,EAAE,iBAAiB,qBAAqB,EAAE,YAAY,gBAAgB,CAAC;YAC7G;QACF;QAEA,OAAO;YACL,IAAI,OAAO,MAAM,KAAK;YACtB;YACA,gBAAgB;QAClB;IACF;AACF;AAEO,MAAM,oBAAoB,IAAI"}},
    {"offset": {"line": 2081, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/voice-intake.ts"],"sourcesContent":["/**\n * Voice intake helper: chunks messy speech into logical units and classifies each\n * into intents (task, reminder, habit, note) with lightweight heuristics.\n * Designed to be paired with LLM refinement but provides deterministic fallbacks.\n */\nimport { GeminiService } from './gemini';\n\nexport type VoiceChunkIntent = 'task' | 'reminder' | 'habit' | 'note' | 'unknown';\n\nexport interface VoiceChunk {\n  raw: string;\n  normalized: string;\n  intent: VoiceChunkIntent;\n  timeExpressions: string[];\n  dueAt?: string | null;\n}\n\nexport class VoiceIntakeService {\n  private geminiService = new GeminiService();\n\n  /**\n   * Processes a transcript using LLM for high-quality intent extraction and temporal normalization.\n   * Falls back to deterministic heuristics if LLM fails or is unavailable.\n   */\n  async process(transcript: string, now: Date = new Date(), timeZone: string = 'UTC'): Promise<VoiceChunk[]> {\n    try {\n      const result = await this.geminiService.processVoiceTranscript(\n        transcript,\n        now,\n        timeZone\n      ) as { chunks?: VoiceChunk[] };\n      if (result && Array.isArray(result.chunks)) {\n        return result.chunks;\n      }\n    } catch (error) {\n      console.error('LLM voice processing failed, falling back to heuristics:', error);\n    }\n\n    return this.splitAndClassifyHeuristic(transcript);\n  }\n\n  splitAndClassifyHeuristic(transcript: string): VoiceChunk[] {\n    // Naive sentence segmentation; in production use a proper NLP splitter.\n    const sentences = transcript\n      .split(/(?<=[.!?])\\s+/)\n      .map(s => s.trim())\n      .filter(Boolean);\n\n    return sentences.map(sentence => {\n      const normalized = sentence.toLowerCase();\n      const intent = this.detectIntent(normalized);\n      const timeExpressions = this.extractTime(normalized);\n      return { raw: sentence, normalized, intent, timeExpressions };\n    });\n  }\n\n  private detectIntent(text: string): VoiceChunkIntent {\n    if (text.includes('every day') || text.includes('daily')) return 'habit';\n    if (text.startsWith('remind') || text.includes('remind me')) return 'reminder';\n    if (text.includes('note') || text.startsWith('note to self')) return 'note';\n    if (text.includes('task') || text.includes('todo') || text.includes('to do')) return 'task';\n    return 'unknown';\n  }\n\n  private extractTime(text: string): string[] {\n    const matches = text.match(/\\b(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday|\\d{1,2}(:\\d{2})?\\s?(am|pm)?|\\d{4}-\\d{2}-\\d{2})\\b/gi);\n    return matches ? matches : [];\n  }\n}\n\nexport const voiceIntakeService = new VoiceIntakeService();\n"],"names":[],"mappings":";;;;;;AAAA;;;;CAIC,GACD;;AAYO,MAAM;IACH,gBAAgB,IAAI,wJAAa,GAAG;IAE5C;;;GAGC,GACD,MAAM,QAAQ,UAAkB,EAAE,MAAY,IAAI,MAAM,EAAE,WAAmB,KAAK,EAAyB;QACzG,IAAI;YACF,MAAM,SAAS,MAAM,IAAI,CAAC,aAAa,CAAC,sBAAsB,CAC5D,YACA,KACA;YAEF,IAAI,UAAU,MAAM,OAAO,CAAC,OAAO,MAAM,GAAG;gBAC1C,OAAO,OAAO,MAAM;YACtB;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4DAA4D;QAC5E;QAEA,OAAO,IAAI,CAAC,yBAAyB,CAAC;IACxC;IAEA,0BAA0B,UAAkB,EAAgB;QAC1D,wEAAwE;QACxE,MAAM,YAAY,WACf,KAAK,CAAC,iBACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,IACf,MAAM,CAAC;QAEV,OAAO,UAAU,GAAG,CAAC,CAAA;YACnB,MAAM,aAAa,SAAS,WAAW;YACvC,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC;YACjC,MAAM,kBAAkB,IAAI,CAAC,WAAW,CAAC;YACzC,OAAO;gBAAE,KAAK;gBAAU;gBAAY;gBAAQ;YAAgB;QAC9D;IACF;IAEQ,aAAa,IAAY,EAAoB;QACnD,IAAI,KAAK,QAAQ,CAAC,gBAAgB,KAAK,QAAQ,CAAC,UAAU,OAAO;QACjE,IAAI,KAAK,UAAU,CAAC,aAAa,KAAK,QAAQ,CAAC,cAAc,OAAO;QACpE,IAAI,KAAK,QAAQ,CAAC,WAAW,KAAK,UAAU,CAAC,iBAAiB,OAAO;QACrE,IAAI,KAAK,QAAQ,CAAC,WAAW,KAAK,QAAQ,CAAC,WAAW,KAAK,QAAQ,CAAC,UAAU,OAAO;QACrF,OAAO;IACT;IAEQ,YAAY,IAAY,EAAY;QAC1C,MAAM,UAAU,KAAK,KAAK,CAAC;QAC3B,OAAO,UAAU,UAAU,EAAE;IAC/B;AACF;AAEO,MAAM,qBAAqB,IAAI"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/email-service.ts"],"sourcesContent":["export interface EmailDraft {\n  to: string[];\n  subject: string;\n  body: string;\n  cc?: string[];\n  bcc?: string[];\n}\n\nexport interface EmailSendOptions {\n  confirmed: boolean; // must be true to actually send\n  dryRun?: boolean; // when true, return payload only\n}\n\n/**\n * Email service stub that enforces explicit preview/confirmation before send.\n * Integrate with provider (e.g., Resend, SES) where indicated.\n */\nexport class EmailService {\n  async preview(draft: EmailDraft) {\n    return {\n      draft,\n      summary: `Ready to send to ${draft.to.join(', ')}`,\n      requiresConfirmation: true,\n    };\n  }\n\n  async send(draft: EmailDraft, options: EmailSendOptions) {\n    if (!options.confirmed) {\n      return {\n        sent: false,\n        requiresConfirmation: true,\n        message: 'Confirmation required before sending email.',\n        draft,\n      };\n    }\n\n    // TODO: plug in real email provider here.\n    if (options.dryRun) {\n      return { sent: false, dryRun: true, payload: draft };\n    }\n\n    // Placeholder success response\n    return { sent: true, id: `email_${Date.now()}`, draft };\n  }\n}\n\nexport const emailService = new EmailService();\n"],"names":[],"mappings":";;;;;;AAiBO,MAAM;IACX,MAAM,QAAQ,KAAiB,EAAE;QAC/B,OAAO;YACL;YACA,SAAS,CAAC,iBAAiB,EAAE,MAAM,EAAE,CAAC,IAAI,CAAC,OAAO;YAClD,sBAAsB;QACxB;IACF;IAEA,MAAM,KAAK,KAAiB,EAAE,OAAyB,EAAE;QACvD,IAAI,CAAC,QAAQ,SAAS,EAAE;YACtB,OAAO;gBACL,MAAM;gBACN,sBAAsB;gBACtB,SAAS;gBACT;YACF;QACF;QAEA,0CAA0C;QAC1C,IAAI,QAAQ,MAAM,EAAE;YAClB,OAAO;gBAAE,MAAM;gBAAO,QAAQ;gBAAM,SAAS;YAAM;QACrD;QAEA,+BAA+B;QAC/B,OAAO;YAAE,MAAM;YAAM,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI;YAAE;QAAM;IACxD;AACF;AAEO,MAAM,eAAe,IAAI"}},
    {"offset": {"line": 2185, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/clickup-service.ts"],"sourcesContent":["export interface ClickUpTaskPayload {\n  name: string;\n  description?: string;\n  status?: string;\n  priority?: number;\n  due_date?: number;\n  time_estimate?: number;\n  tags?: string[];\n  assignees?: string[];\n}\n\nexport interface SyncOptions {\n  allowOverride?: boolean;\n  dryRun?: boolean;\n}\n\n/**\n * ClickUp integration stub with explicit mapping and override controls.\n * Real API calls should respect `allowOverride` and surface a preview before sync.\n */\nexport class ClickUpService {\n  mapTaskToClickUp(task: any): ClickUpTaskPayload {\n    return {\n      name: task.title,\n      description: task.description,\n      status: task.status,\n      priority: this.mapPriority(task.priority),\n      due_date: task.dueDate ? new Date(task.dueDate).getTime() : undefined,\n      time_estimate: task.estimatedTime ? task.estimatedTime * 60000 : undefined,\n      tags: task.tags,\n    };\n  }\n\n  async previewSync(task: any) {\n    const payload = this.mapTaskToClickUp(task);\n    return {\n      payload,\n      requiresConfirmation: true,\n      summary: `Will create/update ClickUp task: \"${payload.name}\" with priority ${payload.priority || 'default'}.`,\n      note: 'AI is a translator; review this mapping before it becomes an authority in ClickUp.',\n    };\n  }\n\n  async syncTask(task: any, options: SyncOptions = {}) {\n    const payload = this.mapTaskToClickUp(task);\n\n    if (!options.allowOverride) {\n      return {\n        synced: false,\n        requiresConfirmation: true,\n        message: 'ClickUp sync requires explicit user confirmation (Philosophy 2.1).',\n        payload,\n      };\n    }\n\n    if (options.dryRun) {\n      return { synced: false, dryRun: true, payload };\n    }\n\n    // TODO: call ClickUp API here\n    return { synced: true, payload, id: `clickup_${Date.now()}` };\n  }\n\n  private mapPriority(priority: string | undefined) {\n    switch (priority) {\n      case 'urgent': return 1;\n      case 'high': return 2;\n      case 'medium': return 3;\n      case 'low': return 4;\n      default: return undefined;\n    }\n  }\n}\n\nexport const clickUpService = new ClickUpService();\n"],"names":[],"mappings":";;;;;;AAoBO,MAAM;IACX,iBAAiB,IAAS,EAAsB;QAC9C,OAAO;YACL,MAAM,KAAK,KAAK;YAChB,aAAa,KAAK,WAAW;YAC7B,QAAQ,KAAK,MAAM;YACnB,UAAU,IAAI,CAAC,WAAW,CAAC,KAAK,QAAQ;YACxC,UAAU,KAAK,OAAO,GAAG,IAAI,KAAK,KAAK,OAAO,EAAE,OAAO,KAAK;YAC5D,eAAe,KAAK,aAAa,GAAG,KAAK,aAAa,GAAG,QAAQ;YACjE,MAAM,KAAK,IAAI;QACjB;IACF;IAEA,MAAM,YAAY,IAAS,EAAE;QAC3B,MAAM,UAAU,IAAI,CAAC,gBAAgB,CAAC;QACtC,OAAO;YACL;YACA,sBAAsB;YACtB,SAAS,CAAC,kCAAkC,EAAE,QAAQ,IAAI,CAAC,gBAAgB,EAAE,QAAQ,QAAQ,IAAI,UAAU,CAAC,CAAC;YAC7G,MAAM;QACR;IACF;IAEA,MAAM,SAAS,IAAS,EAAE,UAAuB,CAAC,CAAC,EAAE;QACnD,MAAM,UAAU,IAAI,CAAC,gBAAgB,CAAC;QAEtC,IAAI,CAAC,QAAQ,aAAa,EAAE;YAC1B,OAAO;gBACL,QAAQ;gBACR,sBAAsB;gBACtB,SAAS;gBACT;YACF;QACF;QAEA,IAAI,QAAQ,MAAM,EAAE;YAClB,OAAO;gBAAE,QAAQ;gBAAO,QAAQ;gBAAM;YAAQ;QAChD;QAEA,8BAA8B;QAC9B,OAAO;YAAE,QAAQ;YAAM;YAAS,IAAI,CAAC,QAAQ,EAAE,KAAK,GAAG,IAAI;QAAC;IAC9D;IAEQ,YAAY,QAA4B,EAAE;QAChD,OAAQ;YACN,KAAK;gBAAU,OAAO;YACtB,KAAK;gBAAQ,OAAO;YACpB,KAAK;gBAAU,OAAO;YACtB,KAAK;gBAAO,OAAO;YACnB;gBAAS,OAAO;QAClB;IACF;AACF;AAEO,MAAM,iBAAiB,IAAI"}},
    {"offset": {"line": 2316, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/groq.ts"],"sourcesContent":["import Groq from 'groq-sdk';\nimport { getEnv } from './env';\n\nexport class GroqService {\n  private client: Groq;\n\n  constructor() {\n    this.client = new Groq({\n      apiKey: getEnv('GROQ_API_KEY') || '',\n    });\n  }\n\n  async transcribe(file: File | Blob): Promise<string> {\n    try {\n      // Groq SDK accepts File objects directly\n      // If we have a Blob, convert it to a File\n      let audioFile: File;\n      if (file instanceof File) {\n        audioFile = file;\n      } else {\n        // Convert Blob to File\n        audioFile = new File([file], 'audio.webm', { \n          type: file.type || 'audio/webm' \n        });\n      }\n\n      // The Groq SDK for Node.js accepts File objects directly\n      // It will handle the file reading internally\n      const transcription = await this.client.audio.transcriptions.create({\n        file: audioFile,\n        model: 'whisper-large-v3-turbo',\n        temperature: 0,\n        response_format: 'verbose_json',\n      });\n\n      return transcription.text;\n    } catch (error) {\n      console.error('Error in Groq transcription service:', error);\n      throw error;\n    }\n  }\n}\n\nexport const groqService = new GroqService();\nexport default GroqService;\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEO,MAAM;IACH,OAAa;IAErB,aAAc;QACZ,IAAI,CAAC,MAAM,GAAG,IAAI,0MAAI,CAAC;YACrB,QAAQ,IAAA,8IAAM,EAAC,mBAAmB;QACpC;IACF;IAEA,MAAM,WAAW,IAAiB,EAAmB;QACnD,IAAI;YACF,yCAAyC;YACzC,0CAA0C;YAC1C,IAAI;YACJ,IAAI,gBAAgB,MAAM;gBACxB,YAAY;YACd,OAAO;gBACL,uBAAuB;gBACvB,YAAY,IAAI,KAAK;oBAAC;iBAAK,EAAE,cAAc;oBACzC,MAAM,KAAK,IAAI,IAAI;gBACrB;YACF;YAEA,yDAAyD;YACzD,6CAA6C;YAC7C,MAAM,gBAAgB,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC;gBAClE,MAAM;gBACN,OAAO;gBACP,aAAa;gBACb,iBAAiB;YACnB;YAEA,OAAO,cAAc,IAAI;QAC3B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wCAAwC;YACtD,MAAM;QACR;IACF;AACF;AAEO,MAAM,cAAc,IAAI;uCAChB"}},
    {"offset": {"line": 2371, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/index.ts"],"sourcesContent":["// Export all services\nexport { GeminiService } from './gemini';\nexport { memoryService, MemoryService } from './memory-service';\nexport { computePressure, getWeekBounds } from './pressure-service';\nexport type { PressureResult } from './pressure-service';\nexport type { SimilarItem, UserContext } from './memory-service';\nexport { validationService, ValidationService } from './validation-service';\nexport { notificationGuard, NotificationGuard } from './notification-guard';\nexport { voiceIntakeService, VoiceIntakeService } from './voice-intake';\nexport { emailService, EmailService } from './email-service';\nexport { clickUpService, ClickUpService } from './clickup-service';\n\n// Export environment utilities\nexport { getEnv, requireEnv } from './env';\n\n// Re-export groq if needed\nexport * from './groq';\n"],"names":[],"mappings":";AAAA,sBAAsB;AACtB;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA,+BAA+B;AAC/B;AAEA,2BAA2B;AAC3B"}},
    {"offset": {"line": 2399, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/apps/web/apps/web/app/api/tasks/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { createServerClient as createClient } from '@automation/auth';\nimport { taskRepo, planRepo } from '@automation/data';\nimport { validationService } from '@automation/services';\n\nexport async function GET(request: NextRequest) {\n  try {\n    const supabase = await createClient();\n    const {\n      data: { user },\n    } = await supabase.auth.getUser();\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const tasks = await taskRepo.getAll({ userId: user.id });\n    return NextResponse.json(tasks);\n  } catch (error: any) {\n    console.error('Error getting tasks:', error);\n    return NextResponse.json(\n      { \n        error: 'Internal server error',\n        message: error.message || 'Failed to fetch tasks',\n        details: error.details || error.toString()\n      },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const supabase = await createClient();\n    const {\n      data: { user },\n    } = await supabase.auth.getUser();\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const body = await request.json();\n    const confirm: boolean = Boolean(body.confirm);\n\n    const draft = {\n      title: body.title ?? 'Untitled',\n      description: body.description,\n      status: (body.status || 'pending') as 'pending' | 'in-progress' | 'completed' | 'cancelled',\n      priority: (body.priority || 'medium') as 'low' | 'medium' | 'high' | 'urgent',\n      estimatedTime: body.estimatedTime ?? 30,\n      focusLevel: (body.focusLevel || 'medium') as 'shallow' | 'medium' | 'deep',\n      dueDate: body.dueAt ? new Date(body.dueAt) : undefined,\n      subtasks: body.subtasks ?? [],\n      dependencies: body.dependencies ?? [],\n      tags: body.tags ?? [],\n      energyRequirement: (body.energyRequirement || 'medium') as 'low' | 'medium' | 'high',\n      context: body.context ?? 'anywhere',\n      kind: (body.kind || 'todo') as 'reminder' | 'todo' | 'habit' | 'daily',\n      projectId: body.projectId ?? undefined,\n      recurrencePerWeek: body.recurrencePerWeek ?? undefined,\n      isRecurring: body.isRecurring ?? undefined,\n      recurrencePattern: body.recurrencePattern ?? undefined,\n    };\n\n    const validation = validationService.validateTaskInput({\n      task: draft,\n      existing: await taskRepo.getAll({ userId: user.id }),\n      projects: (await planRepo.getAll({ userId: user.id })) as any,\n    });\n\n    if (!validation.ok) {\n      return NextResponse.json(\n        { validation, requiresConfirmation: true },\n        { status: 400 }\n      );\n    }\n\n    if (validation.requiresConfirmation && !confirm) {\n      return NextResponse.json(\n        { validation, requiresConfirmation: true },\n        { status: 409 }\n      );\n    }\n\n    const task = await taskRepo.create({ ...draft, userId: user.id });\n\n    return NextResponse.json({ task, validation }, { status: 201 });\n  } catch (error: any) {\n    console.error('Error creating task:', error);\n    return NextResponse.json(\n      { \n        error: 'Internal server error',\n        message: error.message || 'Failed to create task',\n        details: error.details || error.toString()\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,+MAAY;QACnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAE/B,IAAI,CAAC,MAAM;YACT,OAAO,qWAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,QAAQ,MAAM,qJAAQ,CAAC,MAAM,CAAC;YAAE,QAAQ,KAAK,EAAE;QAAC;QACtD,OAAO,qWAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,qWAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,MAAM,OAAO,IAAI;YAC1B,SAAS,MAAM,OAAO,IAAI,MAAM,QAAQ;QAC1C,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,+MAAY;QACnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAE/B,IAAI,CAAC,MAAM;YACT,OAAO,qWAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,UAAmB,QAAQ,KAAK,OAAO;QAE7C,MAAM,QAAQ;YACZ,OAAO,KAAK,KAAK,IAAI;YACrB,aAAa,KAAK,WAAW;YAC7B,QAAS,KAAK,MAAM,IAAI;YACxB,UAAW,KAAK,QAAQ,IAAI;YAC5B,eAAe,KAAK,aAAa,IAAI;YACrC,YAAa,KAAK,UAAU,IAAI;YAChC,SAAS,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI;YAC7C,UAAU,KAAK,QAAQ,IAAI,EAAE;YAC7B,cAAc,KAAK,YAAY,IAAI,EAAE;YACrC,MAAM,KAAK,IAAI,IAAI,EAAE;YACrB,mBAAoB,KAAK,iBAAiB,IAAI;YAC9C,SAAS,KAAK,OAAO,IAAI;YACzB,MAAO,KAAK,IAAI,IAAI;YACpB,WAAW,KAAK,SAAS,IAAI;YAC7B,mBAAmB,KAAK,iBAAiB,IAAI;YAC7C,aAAa,KAAK,WAAW,IAAI;YACjC,mBAAmB,KAAK,iBAAiB,IAAI;QAC/C;QAEA,MAAM,aAAa,2KAAiB,CAAC,iBAAiB,CAAC;YACrD,MAAM;YACN,UAAU,MAAM,qJAAQ,CAAC,MAAM,CAAC;gBAAE,QAAQ,KAAK,EAAE;YAAC;YAClD,UAAW,MAAM,qJAAQ,CAAC,MAAM,CAAC;gBAAE,QAAQ,KAAK,EAAE;YAAC;QACrD;QAEA,IAAI,CAAC,WAAW,EAAE,EAAE;YAClB,OAAO,qWAAY,CAAC,IAAI,CACtB;gBAAE;gBAAY,sBAAsB;YAAK,GACzC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,WAAW,oBAAoB,IAAI,CAAC,SAAS;YAC/C,OAAO,qWAAY,CAAC,IAAI,CACtB;gBAAE;gBAAY,sBAAsB;YAAK,GACzC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,OAAO,MAAM,qJAAQ,CAAC,MAAM,CAAC;YAAE,GAAG,KAAK;YAAE,QAAQ,KAAK,EAAE;QAAC;QAE/D,OAAO,qWAAY,CAAC,IAAI,CAAC;YAAE;YAAM;QAAW,GAAG;YAAE,QAAQ;QAAI;IAC/D,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,qWAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,MAAM,OAAO,IAAI;YAC1B,SAAS,MAAM,OAAO,IAAI,MAAM,QAAQ;QAC1C,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}