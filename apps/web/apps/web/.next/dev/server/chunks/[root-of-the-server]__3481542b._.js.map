{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/storage.ts"],"sourcesContent":["import { promises as fs } from 'fs';\nimport path from 'path';\nimport { Task, Plan, User, Schedule, AgentOutput, Project, Reminder } from '@automation/types';\n\n// Detect if we're in a serverless environment (Netlify Functions, AWS Lambda, etc.)\n// In serverless, filesystem is read-only except for /tmp\nfunction detectServerless(): boolean {\n  const cwd = process.cwd();\n  return !!(\n    process.env.NETLIFY === 'true' ||\n    process.env.AWS_LAMBDA_FUNCTION_NAME ||\n    process.env.VERCEL === '1' ||\n    process.env.LAMBDA_TASK_ROOT ||\n    cwd.includes('/var/task') ||\n    cwd === '/var/task' ||\n    cwd.startsWith('/tmp') ||\n    // Additional check: if cwd is a typical serverless path\n    (cwd.startsWith('/') && !cwd.includes('Desktop') && !cwd.includes('home') && !cwd.includes('Users'))\n  );\n}\n\nfunction getDataDir(): string {\n  const isServerless = detectServerless();\n  // Always use /tmp in serverless - it's the only writable location\n  if (isServerless) {\n    console.log('[STORAGE] Serverless environment detected, using /tmp for data storage');\n    return path.join('/tmp', 'automation-data');\n  }\n  return path.join(process.cwd(), 'data');\n}\n\nconst DATA_DIR = getDataDir();\nconst TASKS_FILE = path.join(DATA_DIR, 'tasks.json');\nconst PLANS_FILE = path.join(DATA_DIR, 'plans.json');\nconst PROJECTS_FILE = path.join(DATA_DIR, 'projects.json');\nconst USERS_FILE = path.join(DATA_DIR, 'users.json');\nconst SCHEDULES_FILE = path.join(DATA_DIR, 'schedules.json');\nconst AGENT_OUTPUTS_FILE = path.join(DATA_DIR, 'agent-outputs.json');\nconst REMINDERS_FILE = path.join(DATA_DIR, 'reminders.json');\n\n// Initialize data directory and files\nasync function ensureDataDir() {\n  const isServerless = detectServerless();\n  try {\n    await fs.mkdir(DATA_DIR, { recursive: true });\n\n    // Create empty JSON files if they don't exist\n    for (const file of [TASKS_FILE, PLANS_FILE, PROJECTS_FILE, USERS_FILE, SCHEDULES_FILE, AGENT_OUTPUTS_FILE, REMINDERS_FILE]) {\n      try {\n        await fs.access(file);\n      } catch {\n        await fs.writeFile(file, '[]');\n      }\n    }\n  } catch (error: any) {\n    // In serverless, if /tmp fails, log but don't throw - we'll handle gracefully\n    if (isServerless && (error.code === 'EROFS' || error.message?.includes('read-only'))) {\n      console.warn('Read-only filesystem detected in serverless environment.');\n      console.warn('Data will not persist. Please migrate to Supabase for production storage.');\n      // Return empty arrays for reads, and log writes (data won't persist)\n      return;\n    }\n    console.error('Error ensuring data directory:', error);\n    throw error;\n  }\n}\n\n// Generic file operations\nasync function readFile<T>(filePath: string): Promise<T[]> {\n  await ensureDataDir();\n  try {\n    const data = await fs.readFile(filePath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Error reading file:', error);\n    return [];\n  }\n}\n\nasync function writeFile<T>(filePath: string, data: T[]): Promise<void> {\n  const isServerless = detectServerless();\n  await ensureDataDir();\n  try {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2));\n  } catch (error: any) {\n    // Handle read-only filesystem in serverless\n    if (error.code === 'EROFS' || error.message?.includes('read-only')) {\n      const errorMsg = `[STORAGE] Cannot write to ${filePath}: Read-only filesystem. ` +\n        `This is expected in serverless environments. Data will not persist between invocations. ` +\n        `Please migrate to Supabase for persistent storage in production.`;\n      console.warn(errorMsg);\n      // Don't throw - allow the app to continue (data just won't persist)\n      // In serverless, /tmp is writable but cleared between invocations\n      return;\n    }\n    console.error('Error writing file:', error);\n    throw error;\n  }\n}\n\n// Task operations\nexport const taskStorage = {\n  getAll: (): Promise<Task[]> => readFile<Task>(TASKS_FILE),\n  byId: async (id: string): Promise<Task | undefined> => {\n    const tasks = await readFile<Task>(TASKS_FILE);\n    return tasks.find(task => task.id === id);\n  },\n  byPlan: async (planId: string): Promise<Task[]> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    const plan = plans.find(p => p.id === planId);\n    if (!plan) return [];\n\n    const tasks = await readFile<Task>(TASKS_FILE);\n    return tasks.filter(task => plan.tasks.includes(task.id));\n  },\n  save: async (task: Task): Promise<void> => {\n    const tasks = await readFile<Task>(TASKS_FILE);\n    const index = tasks.findIndex(t => t.id === task.id);\n\n    if (index >= 0) {\n      // Update existing task\n      tasks[index] = task;\n    } else {\n      // Add new task\n      tasks.push(task);\n    }\n\n    await writeFile(TASKS_FILE, tasks);\n  },\n  delete: async (id: string): Promise<void> => {\n    const tasks = await readFile<Task>(TASKS_FILE);\n    const filtered = tasks.filter(task => task.id !== id);\n    await writeFile(TASKS_FILE, filtered);\n  }\n};\n\n// Plan operations\nexport const planStorage = {\n  getAll: (): Promise<Plan[]> => readFile<Plan>(PLANS_FILE),\n  byId: async (id: string): Promise<Plan | undefined> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    return plans.find(plan => plan.id === id);\n  },\n  save: async (plan: Plan): Promise<void> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    const index = plans.findIndex(p => p.id === plan.id);\n\n    if (index >= 0) {\n      plans[index] = plan;\n    } else {\n      plans.push(plan);\n    }\n\n    await writeFile(PLANS_FILE, plans);\n  },\n  delete: async (id: string): Promise<void> => {\n    const plans = await readFile<Plan>(PLANS_FILE);\n    const filtered = plans.filter(plan => plan.id !== id);\n    await writeFile(PLANS_FILE, filtered);\n  }\n};\n\n// Project operations\nexport const projectStorage = {\n  getAll: (): Promise<Project[]> => readFile<Project>(PROJECTS_FILE),\n  byId: async (id: string): Promise<Project | undefined> => {\n    const projects = await readFile<Project>(PROJECTS_FILE);\n    return projects.find(p => p.id === id);\n  },\n  save: async (project: Project): Promise<void> => {\n    const projects = await readFile<Project>(PROJECTS_FILE);\n    const index = projects.findIndex(p => p.id === project.id);\n    if (index >= 0) projects[index] = project;\n    else projects.push(project);\n    await writeFile(PROJECTS_FILE, projects);\n  },\n  delete: async (id: string): Promise<void> => {\n    const projects = await readFile<Project>(PROJECTS_FILE);\n    await writeFile(PROJECTS_FILE, projects.filter(p => p.id !== id));\n  },\n};\n\n// User operations\nexport const userStorage = {\n  getAll: (): Promise<User[]> => readFile<User>(USERS_FILE),\n  byId: async (id: string): Promise<User | undefined> => {\n    const users = await readFile<User>(USERS_FILE);\n    return users.find(user => user.id === id);\n  },\n  save: async (user: User): Promise<void> => {\n    const users = await readFile<User>(USERS_FILE);\n    const index = users.findIndex(u => u.id === user.id);\n\n    if (index >= 0) {\n      users[index] = user;\n    } else {\n      users.push(user);\n    }\n\n    await writeFile(USERS_FILE, users);\n  }\n};\n\n// Schedule operations\nexport const scheduleStorage = {\n  getAll: (): Promise<Schedule[]> => readFile<Schedule>(SCHEDULES_FILE),\n  byDate: async (date: Date): Promise<Schedule | undefined> => {\n    const schedules = await readFile<Schedule>(SCHEDULES_FILE);\n    return schedules.find(schedule =>\n      new Date(schedule.date).toDateString() === date.toDateString()\n    );\n  },\n  save: async (schedule: Schedule): Promise<void> => {\n    const schedules = await readFile<Schedule>(SCHEDULES_FILE);\n    const index = schedules.findIndex(s => s.id === schedule.id);\n\n    if (index >= 0) {\n      schedules[index] = schedule;\n    } else {\n      schedules.push(schedule);\n    }\n\n    await writeFile(SCHEDULES_FILE, schedules);\n  }\n};\n\n// Agent output operations\nexport const agentOutputStorage = {\n  getAll: (): Promise<AgentOutput[]> => readFile<AgentOutput>(AGENT_OUTPUTS_FILE),\n  save: async (output: AgentOutput): Promise<void> => {\n    const outputs = await readFile<AgentOutput>(AGENT_OUTPUTS_FILE);\n    outputs.push(output);\n    await writeFile(AGENT_OUTPUTS_FILE, outputs);\n  }\n};\n\n// Reminder operations\nexport const reminderStorage = {\n  getAll: (): Promise<Reminder[]> => readFile<Reminder>(REMINDERS_FILE),\n  byId: async (id: string): Promise<Reminder | undefined> => {\n    const reminders = await readFile<Reminder>(REMINDERS_FILE);\n    return reminders.find((reminder) => reminder.id === id);\n  },\n  save: async (reminder: Reminder): Promise<void> => {\n    const reminders = await readFile<Reminder>(REMINDERS_FILE);\n    const index = reminders.findIndex((existing) => existing.id === reminder.id);\n    if (index >= 0) {\n      reminders[index] = reminder;\n    } else {\n      reminders.push(reminder);\n    }\n    await writeFile(REMINDERS_FILE, reminders);\n  },\n  delete: async (id: string): Promise<void> => {\n    const reminders = await readFile<Reminder>(REMINDERS_FILE);\n    const filtered = reminders.filter((reminder) => reminder.id !== id);\n    await writeFile(REMINDERS_FILE, filtered);\n  },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/supabase-client.ts"],"sourcesContent":["import { createClient, SupabaseClient } from '@supabase/supabase-js';\n\nlet supabase: SupabaseClient | null = null;\n\nconst supabaseUrl = process.env.SUPABASE_URL?.trim();\nconst supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY?.trim();\n\nif (supabaseUrl && supabaseKey) {\n  supabase = createClient(supabaseUrl, supabaseKey, {\n    auth: { persistSession: false },\n  });\n} else if (process.env.SUPABASE_URL && process.env.SUPABASE_ANON_KEY) {\n  // For environments that only provide the anon key (e.g., web)\n  supabase = createClient(process.env.SUPABASE_URL.trim(), process.env.SUPABASE_ANON_KEY.trim());\n}\n\nexport function getSupabase() {\n  return supabase;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA,IAAI,WAAkC;AAEtC,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY,EAAE;AAC9C,MAAM,cAAc,QAAQ,GAAG,CAAC,yBAAyB,EAAE;AAE3D,IAAI,eAAe,aAAa;IAC9B,WAAW,IAAA,0QAAY,EAAC,aAAa,aAAa;QAChD,MAAM;YAAE,gBAAgB;QAAM;IAChC;AACF,OAAO,IAAI,QAAQ,GAAG,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,iBAAiB,EAAE;IACpE,8DAA8D;IAC9D,WAAW,IAAA,0QAAY,EAAC,QAAQ,GAAG,CAAC,YAAY,CAAC,IAAI,IAAI,QAAQ,GAAG,CAAC,iBAAiB,CAAC,IAAI;AAC7F;AAEO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/repositories.ts"],"sourcesContent":["import { Task, Plan, User, Schedule, AgentOutput, Project, TaskKind, ScheduledTask, Reminder, ReminderStatus } from '@automation/types';\nimport { taskStorage, planStorage, projectStorage, userStorage, scheduleStorage, agentOutputStorage, reminderStorage } from './storage';\nimport { getSupabase } from './supabase-client';\n\n// Utility function to generate IDs\nfunction generateId(): string {\n  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\n\nconst supabaseClient = getSupabase();\n\nconst ensureArray = (value: unknown): string[] => {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string' && value.length) {\n    try {\n      const parsed = JSON.parse(value);\n      if (Array.isArray(parsed)) return parsed;\n    } catch {\n      return value.split(',').map((it) => it.trim()).filter(Boolean);\n    }\n  }\n  return [];\n};\n\nconst mapTaskRecord = (record: any): Task => {\n  const normalized = {\n    ...record,\n    estimatedTime: record.estimated_time ?? record.estimatedTime ?? 0,\n    actualTime: record.actual_time ?? record.actualTime,\n    focusLevel: record.focus_level ?? record.focusLevel ?? 'medium',\n    dueDate: record.due_date ? new Date(record.due_date) : record.dueDate ? new Date(record.dueDate) : undefined,\n    createdAt: record.created_at ? new Date(record.created_at) : record.createdAt ? new Date(record.createdAt) : new Date(),\n    updatedAt: record.updated_at ? new Date(record.updated_at) : record.updatedAt ? new Date(record.updatedAt) : new Date(),\n    parentTaskId: record.parent_task_id ?? record.parentTaskId,\n    subtasks: ensureArray(record.subtasks ?? record.subtasks_json),\n    dependencies: ensureArray(record.dependencies ?? record.dependencies_json),\n    tags: ensureArray(record.tags ?? record.tags_json),\n    energyRequirement: record.energy_requirement ?? record.energyRequirement ?? 'medium',\n    context: record.context ?? record.location ?? 'anywhere',\n    isRecurring: record.is_recurring ?? record.isRecurring,\n    recurrencePattern: record.recurrence_pattern ?? record.recurrencePattern,\n    kind: record.kind ?? 'todo',\n    projectId: record.project_id ?? record.projectId,\n    recurrencePerWeek: record.recurrence_per_week ?? record.recurrencePerWeek,\n    userId: record.user_id ?? record.userId,\n  };\n\n  return {\n    id: normalized.id,\n    title: normalized.title,\n    description: normalized.description,\n    status: normalized.status,\n    priority: normalized.priority,\n    estimatedTime: normalized.estimatedTime,\n    actualTime: normalized.actualTime,\n    focusLevel: normalized.focusLevel,\n    dueDate: normalized.dueDate,\n    createdAt: normalized.createdAt,\n    updatedAt: normalized.updatedAt,\n    parentTaskId: normalized.parentTaskId,\n    subtasks: normalized.subtasks,\n    dependencies: normalized.dependencies,\n    tags: normalized.tags,\n    energyRequirement: normalized.energyRequirement,\n    context: normalized.context,\n    isRecurring: normalized.isRecurring,\n    recurrencePattern: normalized.recurrencePattern,\n    kind: normalized.kind,\n    projectId: normalized.projectId,\n    recurrencePerWeek: normalized.recurrencePerWeek,\n    userId: normalized.userId,\n  };\n};\n\nconst buildTaskPayload = (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Record<string, any> => ({\n  title: task.title,\n  description: task.description ?? null,\n  status: task.status,\n  priority: task.priority,\n  estimated_time: task.estimatedTime,\n  actual_time: task.actualTime ?? null,\n  focus_level: task.focusLevel,\n  due_date: task.dueDate ? task.dueDate.toISOString() : null,\n  parent_task_id: task.parentTaskId ?? null,\n  subtasks: task.subtasks ?? [],\n  dependencies: task.dependencies ?? [],\n  tags: task.tags ?? [],\n  energy_requirement: task.energyRequirement,\n  context: task.context,\n  is_recurring: task.isRecurring ?? false,\n  recurrence_pattern: task.recurrencePattern ?? null,\n  kind: task.kind ?? 'todo',\n  project_id: task.projectId ?? null,\n  recurrence_per_week: task.recurrencePerWeek ?? null,\n  user_id: task.userId ?? null,\n});\n\nconst buildTaskUpdatePayload = (\n  updates: Partial<Omit<Task, 'id' | 'createdAt'>>\n): Record<string, any> => {\n  const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n  if (updates.title !== undefined) payload.title = updates.title;\n  if (updates.description !== undefined) payload.description = updates.description;\n  if (updates.status !== undefined) payload.status = updates.status;\n  if (updates.priority !== undefined) payload.priority = updates.priority;\n  if (updates.estimatedTime !== undefined) payload.estimated_time = updates.estimatedTime;\n  if (updates.actualTime !== undefined) payload.actual_time = updates.actualTime;\n  if (updates.focusLevel !== undefined) payload.focus_level = updates.focusLevel;\n  if (updates.dueDate !== undefined) payload.due_date = updates.dueDate ? updates.dueDate.toISOString() : null;\n  if (updates.parentTaskId !== undefined) payload.parent_task_id = updates.parentTaskId;\n  if (updates.subtasks !== undefined) payload.subtasks = updates.subtasks;\n  if (updates.dependencies !== undefined) payload.dependencies = updates.dependencies;\n  if (updates.tags !== undefined) payload.tags = updates.tags;\n  if (updates.energyRequirement !== undefined) payload.energy_requirement = updates.energyRequirement;\n  if (updates.context !== undefined) payload.context = updates.context;\n  if (updates.isRecurring !== undefined) payload.is_recurring = updates.isRecurring;\n  if (updates.recurrencePattern !== undefined) payload.recurrence_pattern = updates.recurrencePattern;\n  if (updates.kind !== undefined) payload.kind = updates.kind;\n  if (updates.projectId !== undefined) payload.project_id = updates.projectId;\n  if (updates.recurrencePerWeek !== undefined) payload.recurrence_per_week = updates.recurrencePerWeek;\n  if (updates.userId !== undefined) payload.user_id = updates.userId;\n  return payload;\n};\n\nconst parseJsonField = (value: unknown, fallback: any = null) => {\n  if (value === null || value === undefined) return fallback;\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value);\n    } catch {\n      return fallback;\n    }\n  }\n  return value;\n};\n\nconst normalizeScheduledTasks = (value: unknown): ScheduledTask[] => {\n  const raw = Array.isArray(value) ? value : [];\n  return raw.map((task: any) => ({\n    taskId: task.taskId ?? task.task_id ?? '',\n    scheduledStart: task.scheduledStart\n      ? new Date(task.scheduledStart)\n      : task.scheduled_start\n      ? new Date(task.scheduled_start)\n      : new Date(),\n    scheduledEnd: task.scheduledEnd\n      ? new Date(task.scheduledEnd)\n      : task.scheduled_end\n      ? new Date(task.scheduled_end)\n      : new Date(),\n    actualStart: task.actualStart\n      ? new Date(task.actualStart)\n      : task.actual_start\n      ? new Date(task.actual_start)\n      : undefined,\n    actualEnd: task.actualEnd\n      ? new Date(task.actualEnd)\n      : task.actual_end\n      ? new Date(task.actual_end)\n      : undefined,\n    status: task.status ?? 'scheduled',\n    location: task.location ?? null,\n    context: task.context ?? null,\n  }));\n};\n\nconst serializeScheduledTasks = (tasks: ScheduledTask[]): any[] =>\n  tasks.map((task) => ({\n    taskId: task.taskId,\n    scheduledStart: task.scheduledStart.toISOString(),\n    scheduledEnd: task.scheduledEnd.toISOString(),\n    actualStart: task.actualStart ? task.actualStart.toISOString() : null,\n    actualEnd: task.actualEnd ? task.actualEnd.toISOString() : null,\n    status: task.status,\n    location: task.location ?? null,\n    context: task.context ?? null,\n  }));\n\nconst mapPlanRecord = (record: any): Plan => ({\n  id: record.id,\n  title: record.title,\n  description: record.description,\n  status: record.status,\n  tasks: ensureArray(record.tasks ?? record.task_ids),\n  createdAt: record.created_at ? new Date(record.created_at) : new Date(),\n  updatedAt: record.updated_at ? new Date(record.updated_at) : new Date(),\n  startDate: record.start_date ? new Date(record.start_date) : undefined,\n  endDate: record.end_date ? new Date(record.end_date) : undefined,\n  goal: record.goal ?? '',\n  constraints: parseJsonField(record.constraints, {}),\n  userId: record.user_id ?? undefined,\n});\n\nconst buildPlanPayload = (plan: Omit<Plan, 'id' | 'createdAt' | 'updatedAt'>): Record<string, any> => ({\n  title: plan.title,\n  description: plan.description ?? null,\n  status: plan.status,\n  tasks: plan.tasks ?? [],\n  start_date: plan.startDate ? plan.startDate.toISOString() : null,\n  end_date: plan.endDate ? plan.endDate.toISOString() : null,\n  goal: plan.goal,\n  constraints: plan.constraints ?? {},\n  user_id: plan.userId ?? null,\n});\n\nconst buildPlanUpdatePayload = (\n  updates: Partial<Omit<Plan, 'id' | 'createdAt'>>\n): Record<string, any> => {\n  const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n  if (updates.title !== undefined) payload.title = updates.title;\n  if (updates.description !== undefined) payload.description = updates.description;\n  if (updates.status !== undefined) payload.status = updates.status;\n  if (updates.tasks !== undefined) payload.tasks = updates.tasks;\n  if (updates.startDate !== undefined)\n    payload.start_date = updates.startDate ? updates.startDate.toISOString() : null;\n  if (updates.endDate !== undefined)\n    payload.end_date = updates.endDate ? updates.endDate.toISOString() : null;\n  if (updates.goal !== undefined) payload.goal = updates.goal;\n  if (updates.constraints !== undefined) payload.constraints = updates.constraints;\n  if (updates.userId !== undefined) payload.user_id = updates.userId;\n  return payload;\n};\n\nconst mapScheduleRecord = (record: any): Schedule => ({\n  id: record.id,\n  date: record.date ? new Date(record.date) : new Date(),\n  tasks: normalizeScheduledTasks(parseJsonField(record.tasks, [])),\n  notes: record.notes ?? '',\n  energyProfile: parseJsonField(record.energy_profile, {\n    peakHours: [],\n    mediumHours: [],\n    lowHours: [],\n    recoveryTime: 0,\n  }),\n  constraints: parseJsonField(record.constraints, { maxTasks: 0, maxDeepWorkSessions: 0 }),\n  validation: parseJsonField(record.validation, undefined),\n  userId: record.user_id ?? undefined,\n  createdAt: record.created_at ? new Date(record.created_at) : new Date(),\n  updatedAt: record.updated_at ? new Date(record.updated_at) : new Date(),\n});\n\nconst buildSchedulePayload = (\n  schedule: Omit<Schedule, 'id' | 'createdAt' | 'updatedAt'>\n): Record<string, any> => ({\n  date: schedule.date.toISOString(),\n  tasks: serializeScheduledTasks(schedule.tasks ?? []),\n  notes: schedule.notes ?? '',\n  energy_profile: schedule.energyProfile ?? {},\n  constraints: schedule.constraints ?? {},\n  validation: schedule.validation ?? null,\n  user_id: schedule.userId ?? null,\n});\n\nconst normalizeReminderAttempts = (value: unknown): Reminder['attempts'] => {\n  const raw = Array.isArray(value) ? value : [];\n  return raw\n    .filter((attempt) => attempt && typeof attempt === 'object')\n    .map((attempt: any) => ({\n      channel: attempt.channel,\n      status: attempt.status,\n      message: attempt.message ?? '',\n      timestamp: attempt.timestamp\n        ? new Date(attempt.timestamp)\n        : attempt.created_at\n        ? new Date(attempt.created_at)\n        : new Date(),\n    }));\n};\n\nconst mapReminderRecord = (record: any): Reminder => ({\n  id: record.id,\n  userId: record.user_id ?? record.userId ?? '',\n  title: record.title ?? '',\n  message: record.message ?? '',\n  dueAt: record.due_at ? new Date(record.due_at) : record.dueAt ? new Date(record.dueAt) : new Date(),\n  channels: ensureArray(record.channels ?? record.channels_json) as Reminder['channels'],\n  status: (record.status ?? 'pending') as ReminderStatus,\n  lastSentAt: record.last_sent_at\n    ? new Date(record.last_sent_at)\n    : record.lastSentAt\n    ? new Date(record.lastSentAt)\n    : undefined,\n  sentChannels: ensureArray(record.sent_channels ?? record.sentChannels) as Reminder['channels'],\n  failedChannels: ensureArray(record.failed_channels ?? record.failedChannels) as Reminder['channels'],\n  attempts: normalizeReminderAttempts(parseJsonField(record.attempts, [])),\n  recipientEmail: record.recipient_email ?? record.recipientEmail ?? undefined,\n  pushTokens: ensureArray(record.push_tokens ?? record.pushTokens),\n  metadata: parseJsonField(record.metadata, {}),\n  createdAt: record.created_at ? new Date(record.created_at) : record.createdAt ? new Date(record.createdAt) : new Date(),\n  updatedAt: record.updated_at ? new Date(record.updated_at) : record.updatedAt ? new Date(record.updatedAt) : new Date(),\n});\n\nconst buildReminderPayload = (\n  reminder: Omit<Reminder, 'id' | 'createdAt' | 'updatedAt'>\n): Record<string, any> => ({\n  user_id: reminder.userId,\n  title: reminder.title,\n  message: reminder.message,\n  due_at: reminder.dueAt.toISOString(),\n  channels: reminder.channels ?? [],\n  status: reminder.status,\n  last_sent_at: reminder.lastSentAt ? reminder.lastSentAt.toISOString() : null,\n  sent_channels: reminder.sentChannels ?? [],\n  failed_channels: reminder.failedChannels ?? [],\n  attempts: (reminder.attempts ?? []).map((attempt) => ({\n    channel: attempt.channel,\n    status: attempt.status,\n    message: attempt.message,\n    timestamp: attempt.timestamp.toISOString(),\n  })),\n  recipient_email: reminder.recipientEmail ?? null,\n  push_tokens: reminder.pushTokens ?? [],\n  metadata: reminder.metadata ?? {},\n});\n\nconst buildReminderUpdatePayload = (\n  updates: Partial<Omit<Reminder, 'id' | 'createdAt'>>\n): Record<string, any> => {\n  const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n  if (updates.userId !== undefined) payload.user_id = updates.userId;\n  if (updates.title !== undefined) payload.title = updates.title;\n  if (updates.message !== undefined) payload.message = updates.message;\n  if (updates.dueAt !== undefined) payload.due_at = updates.dueAt.toISOString();\n  if (updates.channels !== undefined) payload.channels = updates.channels;\n  if (updates.status !== undefined) payload.status = updates.status;\n  if (updates.lastSentAt !== undefined) {\n    payload.last_sent_at = updates.lastSentAt ? updates.lastSentAt.toISOString() : null;\n  }\n  if (updates.sentChannels !== undefined) payload.sent_channels = updates.sentChannels;\n  if (updates.failedChannels !== undefined) payload.failed_channels = updates.failedChannels;\n  if (updates.attempts !== undefined) {\n    payload.attempts = updates.attempts.map((attempt) => ({\n      channel: attempt.channel,\n      status: attempt.status,\n      message: attempt.message,\n      timestamp: attempt.timestamp.toISOString(),\n    }));\n  }\n  if (updates.recipientEmail !== undefined) payload.recipient_email = updates.recipientEmail;\n  if (updates.pushTokens !== undefined) payload.push_tokens = updates.pushTokens;\n  if (updates.metadata !== undefined) payload.metadata = updates.metadata;\n  return payload;\n};\n\n// Task Repository\nexport const taskRepo = {\n  getAll: async (options?: { userId?: string }): Promise<Task[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('tasks').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n\n        const { data, error } = await query;\n        if (error) {\n          console.warn('Supabase task fetch error:', error.message);\n        } else if (data) {\n          return data.map(mapTaskRecord);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    return await taskStorage.getAll();\n  },\n  \n  getById: async (id: string): Promise<Task | null> => {\n    if (supabaseClient) {\n      try {\n        const { data, error } = await supabaseClient\n          .from('tasks')\n          .select('*')\n          .eq('id', id)\n          .single();\n\n        if (!error && data) {\n          return mapTaskRecord(data);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase getById failed:', error);\n      }\n    }\n\n    const task = await taskStorage.byId(id);\n    return task || null;\n  },\n  \n  create: async (taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          ...buildTaskPayload(taskData),\n          id: generateId(),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('tasks')\n          .insert(payload)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapTaskRecord(data);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const task: Task = {\n      ...taskData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n    \n    await taskStorage.save(task);\n    return task;\n  },\n  \n  update: async (id: string, updates: Partial<Omit<Task, 'id' | 'createdAt'>>): Promise<Task | null> => {\n    if (supabaseClient) {\n      try {\n        const payload = buildTaskUpdatePayload(updates);\n        const { data, error } = await supabaseClient\n          .from('tasks')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapTaskRecord(data);\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase update failed:', error);\n      }\n    }\n\n    const task = await taskStorage.byId(id);\n    if (!task) return null;\n    \n    const updatedTask: Task = {\n      ...task,\n      ...updates,\n      updatedAt: new Date()\n    };\n    \n    await taskStorage.save(updatedTask);\n    return updatedTask;\n  },\n  \n  delete: async (id: string): Promise<boolean> => {\n    if (supabaseClient) {\n      try {\n        const { error } = await supabaseClient\n          .from('tasks')\n          .delete()\n          .eq('id', id);\n\n        if (!error) {\n          return true;\n        }\n      } catch (error) {\n        console.warn('[taskRepo] Supabase delete failed:', error);\n      }\n    }\n\n    try {\n      await taskStorage.delete(id);\n      return true;\n    } catch (error) {\n      console.error('Error deleting task:', error);\n      return false;\n    }\n  },\n  \n  getByPlan: async (planId: string): Promise<Task[]> => {\n    return await taskStorage.byPlan(planId);\n  },\n  \n  // Find tasks that are due soon\n  getByDueDate: async (startDate: Date, endDate: Date): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => {\n      if (!task.dueDate) return false;\n      const dueDate = new Date(task.dueDate);\n      return dueDate >= startDate && dueDate <= endDate;\n    });\n  },\n  \n  // Find tasks with specific tags\n  getByTags: async (tags: string[]): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => \n      tags.some(tag => task.tags.includes(tag))\n    );\n  },\n  \n  // Get tasks with specific status\n  getByStatus: async (status: Task['status']): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => task.status === status);\n  },\n\n  getByProject: async (projectId: string): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => task.projectId === projectId);\n  },\n\n  getByKind: async (kind: TaskKind): Promise<Task[]> => {\n    const tasks = await taskStorage.getAll();\n    return tasks.filter(task => (task.kind ?? 'todo') === kind);\n  },\n};\n\n// Plan Repository\nexport const planRepo = {\n  getAll: async (options?: { userId?: string }): Promise<Plan[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('plans').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (error) {\n          console.warn('[planRepo] Supabase getAll error:', error.message);\n        } else if (data) {\n          return data.map(mapPlanRecord);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    return await planStorage.getAll();\n  },\n  \n  getById: async (id: string): Promise<Plan | null> => {\n    if (supabaseClient) {\n      try {\n        const { data, error } = await supabaseClient\n          .from('plans')\n          .select('*')\n          .eq('id', id)\n          .single();\n\n        if (!error && data) {\n          return mapPlanRecord(data);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase getById failed:', error);\n      }\n    }\n\n    const plan = await planStorage.byId(id);\n    return plan || null;\n  },\n  \n  create: async (planData: Omit<Plan, 'id' | 'createdAt' | 'updatedAt'>): Promise<Plan> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          id: generateId(),\n          ...buildPlanPayload(planData),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('plans')\n          .insert(payload)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapPlanRecord(data);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const plan: Plan = {\n      ...planData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n    \n    await planStorage.save(plan);\n    return plan;\n  },\n  \n  update: async (id: string, updates: Partial<Omit<Plan, 'id' | 'createdAt'>>): Promise<Plan | null> => {\n    if (supabaseClient) {\n      try {\n        const payload = buildPlanUpdatePayload(updates);\n        const { data, error } = await supabaseClient\n          .from('plans')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapPlanRecord(data);\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase update failed:', error);\n      }\n    }\n\n    const plan = await planStorage.byId(id);\n    if (!plan) return null;\n    \n    const updatedPlan: Plan = {\n      ...plan,\n      ...updates,\n      updatedAt: new Date()\n    };\n    \n    await planStorage.save(updatedPlan);\n    return updatedPlan;\n  },\n  \n  delete: async (id: string): Promise<boolean> => {\n    if (supabaseClient) {\n      try {\n        const { error } = await supabaseClient\n          .from('plans')\n          .delete()\n          .eq('id', id);\n\n        if (!error) {\n          return true;\n        }\n      } catch (error) {\n        console.warn('[planRepo] Supabase delete failed:', error);\n      }\n    }\n\n    try {\n      await planStorage.delete(id);\n      return true;\n    } catch (error) {\n      console.error('Error deleting plan:', error);\n      return false;\n    }\n  },\n  \n  getByStatus: async (status: Plan['status'], options?: { userId?: string }): Promise<Plan[]> => {\n    const plans = await planRepo.getAll(options);\n    return plans.filter(plan => plan.status === status);\n  }\n};\n\n// Project Repository\nexport const projectRepo = {\n  getAll: async (): Promise<Project[]> => await projectStorage.getAll(),\n  getById: async (id: string): Promise<Project | null> => {\n    const p = await projectStorage.byId(id);\n    return p ?? null;\n  },\n  create: async (data: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<Project> => {\n    const now = new Date();\n    const project: Project = {\n      ...data,\n      id: generateId(),\n      taskIds: data.taskIds || [],\n      createdAt: now,\n      updatedAt: now,\n    };\n    await projectStorage.save(project);\n    return project;\n  },\n  update: async (id: string, updates: Partial<Omit<Project, 'id' | 'createdAt'>>): Promise<Project | null> => {\n    const project = await projectStorage.byId(id);\n    if (!project) return null;\n    const updated = { ...project, ...updates, updatedAt: new Date() };\n    await projectStorage.save(updated);\n    return updated;\n  },\n  delete: async (id: string): Promise<boolean> => {\n    try {\n      await projectStorage.delete(id);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n};\n\n// User Repository\nexport const userRepo = {\n  getAll: async (): Promise<User[]> => {\n    return await userStorage.getAll();\n  },\n\n  getById: async (id: string): Promise<User | null> => {\n    const user = await userStorage.byId(id);\n    return user || null;\n  },\n\n  create: async (userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>, id?: string): Promise<User> => {\n    const now = new Date();\n    const user: User = {\n      ...userData,\n      id: id || generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n\n    await userStorage.save(user);\n    return user;\n  },\n\n  update: async (id: string, updates: Partial<Omit<User, 'id' | 'createdAt'>>): Promise<User | null> => {\n    const user = await userStorage.byId(id);\n    if (!user) return null;\n\n    const updatedUser: User = {\n      ...user,\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    await userStorage.save(updatedUser);\n    return updatedUser;\n  }\n};\n\n// Schedule Repository\nexport const scheduleRepo = {\n  getAll: async (options?: { userId?: string }): Promise<Schedule[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('schedules').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (error) {\n          console.warn('[scheduleRepo] Supabase getAll error:', error.message);\n        } else if (data) {\n          return data.map(mapScheduleRecord);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    return await scheduleStorage.getAll();\n  },\n\n  getByDate: async (date: Date, options?: { userId?: string }): Promise<Schedule | null> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient\n          .from('schedules')\n          .select('*')\n          .eq('date', date.toISOString().split('T')[0]);\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (!error && data && data.length) {\n          return mapScheduleRecord(data[0]);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase getByDate failed:', error);\n      }\n    }\n\n    const schedule = await scheduleStorage.byDate(date);\n    return schedule || null;\n  },\n\n  create: async (scheduleData: Omit<Schedule, 'id' | 'createdAt' | 'updatedAt'>): Promise<Schedule> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          id: generateId(),\n          ...buildSchedulePayload(scheduleData),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('schedules')\n          .insert(payload)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapScheduleRecord(data);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const schedule: Schedule = {\n      ...scheduleData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now\n    };\n\n    await scheduleStorage.save(schedule);\n    return schedule;\n  },\n\n  update: async (id: string, updates: Partial<Omit<Schedule, 'id' | 'createdAt'>>): Promise<Schedule | null> => {\n    if (supabaseClient) {\n      try {\n        const payload: Record<string, any> = { updated_at: new Date().toISOString() };\n        if (updates.date !== undefined) payload.date = updates.date.toISOString();\n        if (updates.tasks !== undefined) payload.tasks = updates.tasks;\n        if (updates.notes !== undefined) payload.notes = updates.notes;\n        if (updates.energyProfile !== undefined) payload.energy_profile = updates.energyProfile;\n        if (updates.constraints !== undefined) payload.constraints = updates.constraints;\n        if (updates.validation !== undefined) payload.validation = updates.validation;\n        if (updates.userId !== undefined) payload.user_id = updates.userId;\n\n        const { data, error } = await supabaseClient\n          .from('schedules')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n\n        if (!error && data) {\n          return mapScheduleRecord(data);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase update failed:', error);\n      }\n    }\n\n    const schedules = await scheduleStorage.getAll();\n    const schedule = schedules.find(s => s.id === id);\n    if (!schedule) return null;\n\n    const updatedSchedule: Schedule = {\n      ...schedule,\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    await scheduleStorage.save(updatedSchedule);\n    return updatedSchedule;\n  },\n\n  getByDateRange: async (startDate: Date, endDate: Date, options?: { userId?: string }): Promise<Schedule[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient\n          .from('schedules')\n          .select('*')\n          .gte('date', startDate.toISOString().split('T')[0])\n          .lte('date', endDate.toISOString().split('T')[0]);\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (!error && data) {\n          return data.map(mapScheduleRecord);\n        }\n      } catch (error) {\n        console.warn('[scheduleRepo] Supabase getByDateRange failed:', error);\n      }\n    }\n\n    const schedules = await scheduleStorage.getAll();\n    return schedules.filter(schedule => {\n      const scheduleDate = new Date(schedule.date);\n      return scheduleDate >= startDate && scheduleDate <= endDate;\n    });\n  }\n};\n\n// Agent Output Repository\nexport const agentOutputRepo = {\n  getAll: async (): Promise<AgentOutput[]> => {\n    return await agentOutputStorage.getAll();\n  },\n\n  create: async (outputData: Omit<AgentOutput, 'timestamp'>): Promise<AgentOutput> => {\n    const output: AgentOutput = {\n      ...outputData,\n      timestamp: new Date()\n    };\n\n    await agentOutputStorage.save(output);\n    return output;\n  },\n\n  getByAgentType: async (agentType: AgentOutput['agentType']): Promise<AgentOutput[]> => {\n    const outputs = await agentOutputStorage.getAll();\n    return outputs.filter(output => output.agentType === agentType);\n  }\n};\n\n// Reminder Repository\nexport const reminderRepo = {\n  getAll: async (options?: { userId?: string; status?: ReminderStatus }): Promise<Reminder[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient.from('reminders').select('*');\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        if (options?.status) {\n          query = query.eq('status', options.status);\n        }\n        const { data, error } = await query;\n        if (!error && data) {\n          return data.map(mapReminderRecord);\n        }\n        if (error) {\n          console.warn('[reminderRepo] Supabase getAll error:', error.message);\n        }\n      } catch (error) {\n        console.warn('[reminderRepo] Supabase getAll failed:', error);\n      }\n    }\n\n    const reminders = await reminderStorage.getAll();\n    return reminders.filter((reminder) => {\n      if (options?.userId && reminder.userId !== options.userId) return false;\n      if (options?.status && reminder.status !== options.status) return false;\n      return true;\n    });\n  },\n\n  getById: async (id: string): Promise<Reminder | null> => {\n    if (supabaseClient) {\n      try {\n        const { data, error } = await supabaseClient\n          .from('reminders')\n          .select('*')\n          .eq('id', id)\n          .single();\n        if (!error && data) {\n          return mapReminderRecord(data);\n        }\n      } catch (error) {\n        console.warn('[reminderRepo] Supabase getById failed:', error);\n      }\n    }\n\n    const reminder = await reminderStorage.byId(id);\n    return reminder || null;\n  },\n\n  create: async (\n    reminderData: Omit<Reminder, 'id' | 'createdAt' | 'updatedAt'>\n  ): Promise<Reminder> => {\n    if (supabaseClient) {\n      try {\n        const payload = {\n          id: generateId(),\n          ...buildReminderPayload(reminderData),\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        const { data, error } = await supabaseClient\n          .from('reminders')\n          .insert(payload)\n          .select('*')\n          .single();\n        if (!error && data) {\n          return mapReminderRecord(data);\n        }\n      } catch (error) {\n        console.warn('[reminderRepo] Supabase create failed:', error);\n      }\n    }\n\n    const now = new Date();\n    const reminder: Reminder = {\n      ...reminderData,\n      id: generateId(),\n      createdAt: now,\n      updatedAt: now,\n    };\n    await reminderStorage.save(reminder);\n    return reminder;\n  },\n\n  update: async (\n    id: string,\n    updates: Partial<Omit<Reminder, 'id' | 'createdAt'>>\n  ): Promise<Reminder | null> => {\n    if (supabaseClient) {\n      try {\n        const payload = buildReminderUpdatePayload(updates);\n        const { data, error } = await supabaseClient\n          .from('reminders')\n          .update(payload)\n          .eq('id', id)\n          .select('*')\n          .single();\n        if (!error && data) {\n          return mapReminderRecord(data);\n        }\n      } catch (error) {\n        console.warn('[reminderRepo] Supabase update failed:', error);\n      }\n    }\n\n    const reminder = await reminderStorage.byId(id);\n    if (!reminder) return null;\n\n    const updatedReminder: Reminder = {\n      ...reminder,\n      ...updates,\n      updatedAt: new Date(),\n    };\n    await reminderStorage.save(updatedReminder);\n    return updatedReminder;\n  },\n\n  delete: async (id: string): Promise<boolean> => {\n    if (supabaseClient) {\n      try {\n        const { error } = await supabaseClient\n          .from('reminders')\n          .delete()\n          .eq('id', id);\n        if (!error) {\n          return true;\n        }\n      } catch (error) {\n        console.warn('[reminderRepo] Supabase delete failed:', error);\n      }\n    }\n\n    try {\n      await reminderStorage.delete(id);\n      return true;\n    } catch (error) {\n      console.error('[reminderRepo] local delete failed:', error);\n      return false;\n    }\n  },\n\n  getDue: async (now: Date, options?: { userId?: string }): Promise<Reminder[]> => {\n    if (supabaseClient) {\n      try {\n        let query = supabaseClient\n          .from('reminders')\n          .select('*')\n          .eq('status', 'pending')\n          .lte('due_at', now.toISOString());\n        if (options?.userId) {\n          query = query.eq('user_id', options.userId);\n        }\n        const { data, error } = await query;\n        if (!error && data) {\n          return data.map(mapReminderRecord);\n        }\n      } catch (error) {\n        console.warn('[reminderRepo] Supabase getDue failed:', error);\n      }\n    }\n\n    const reminders = await reminderStorage.getAll();\n    return reminders.filter((reminder) => {\n      if (reminder.status !== 'pending') return false;\n      if (options?.userId && reminder.userId !== options.userId) return false;\n      return new Date(reminder.dueAt) <= now;\n    });\n  },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1230, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/data/src/index.ts"],"sourcesContent":["// Export storage layer\nexport * from './storage';\n\n// Export repositories\nexport * from './repositories';\n"],"names":[],"mappings":";AAAA,uBAAuB;AACvB;AAEA,sBAAsB;AACtB"}},
    {"offset": {"line": 1241, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/env.ts"],"sourcesContent":["// Platform-agnostic environment variable access\n// Works in both Node.js (web) and React Native (mobile)\n\nlet expoConstants: any = null;\n\n// Try to import expo-constants if we're in React Native\ntry {\n  expoConstants = require('expo-constants').default;\n} catch (e) {\n  // Not in React Native environment, will use process.env\n}\n\nexport function getEnv(key: string): string | undefined {\n  // React Native: use Expo Constants\n  if (expoConstants?.expoConfig?.extra) {\n    return expoConstants.expoConfig.extra[key];\n  }\n\n  // Node.js: use process.env\n  if (typeof process !== 'undefined' && process.env) {\n    return process.env[key];\n  }\n\n  return undefined;\n}\n\nexport function requireEnv(key: string): string {\n  const value = getEnv(key);\n  if (!value) {\n    throw new Error(`Required environment variable ${key} is not set`);\n  }\n  return value;\n}\n"],"names":[],"mappings":";;;;;;AAAA,gDAAgD;AAChD,wDAAwD;AAExD,IAAI,gBAAqB;AAEzB,wDAAwD;AACxD,IAAI;IACF,gBAAgB,gQAA0B,OAAO;AACnD,EAAE,OAAO,GAAG;AACV,wDAAwD;AAC1D;AAEO,SAAS,OAAO,GAAW;IAChC,mCAAmC;IACnC,IAAI,eAAe,YAAY,OAAO;QACpC,OAAO,cAAc,UAAU,CAAC,KAAK,CAAC,IAAI;IAC5C;IAEA,2BAA2B;IAC3B,IAAI,OAAO,YAAY,eAAe,QAAQ,GAAG,EAAE;QACjD,OAAO,QAAQ,GAAG,CAAC,IAAI;IACzB;IAEA,OAAO;AACT;AAEO,SAAS,WAAW,GAAW;IACpC,MAAM,QAAQ,OAAO;IACrB,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,IAAI,WAAW,CAAC;IACnE;IACA,OAAO;AACT"}},
    {"offset": {"line": 1278, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/utils/src/index.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\n/**\n * Gemini often returns JSON wrapped in ```json ... ``` or ``` ... ```.\n * Strip those before parsing.\n */\nexport function parseJsonFromGemini(raw: string): unknown {\n  const trimmed = raw.trim()\n  const codeBlock = trimmed.match(/```(?:json)?\\s*([\\s\\S]*?)```/)\n  const jsonStr = codeBlock ? codeBlock[1].trim() : trimmed\n  return JSON.parse(jsonStr)\n}\n\n/**\n * Convert a Date into a specific IANA timezone without mutating the original date.\n * Relies on Intl API (works in Node 18+ and modern browsers).\n */\nexport function toTimeZone(date: Date, timeZone: string): Date {\n  const iso = date.toLocaleString('en-US', { timeZone })\n  return new Date(iso)\n}\n\n/**\n * Normalize a fuzzy time phrase into a target Date using a fallback day and timezone.\n * This is a minimal heuristic; callers should still ask for user confirmation.\n */\nexport function normalizeFuzzyTime(\n  phrase: string,\n  now: Date,\n  timeZone: string\n): Date | null {\n  const lower = phrase.toLowerCase().trim()\n  const base = toTimeZone(now, timeZone)\n\n  if (['today', 'tonight'].includes(lower)) return base\n  if (lower === 'tomorrow') {\n    const d = new Date(base)\n    d.setDate(d.getDate() + 1)\n    return d\n  }\n  if (lower.match(/^in \\\\d+ (minutes|min)$/)) {\n    const mins = parseInt(lower.match(/\\\\d+/)?.[0] || '0', 10)\n    const d = new Date(base)\n    d.setMinutes(d.getMinutes() + mins)\n    return d\n  }\n  if (lower.match(/^in \\\\d+ (hours|hrs|hour)$/)) {\n    const hrs = parseInt(lower.match(/\\\\d+/)?.[0] || '0', 10)\n    const d = new Date(base)\n    d.setHours(d.getHours() + hrs)\n    return d\n  }\n  return null\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,sOAAO,EAAC,IAAA,gMAAI,EAAC;AACtB;AAMO,SAAS,oBAAoB,GAAW;IAC7C,MAAM,UAAU,IAAI,IAAI;IACxB,MAAM,YAAY,QAAQ,KAAK,CAAC;IAChC,MAAM,UAAU,YAAY,SAAS,CAAC,EAAE,CAAC,IAAI,KAAK;IAClD,OAAO,KAAK,KAAK,CAAC;AACpB;AAMO,SAAS,WAAW,IAAU,EAAE,QAAgB;IACrD,MAAM,MAAM,KAAK,cAAc,CAAC,SAAS;QAAE;IAAS;IACpD,OAAO,IAAI,KAAK;AAClB;AAMO,SAAS,mBACd,MAAc,EACd,GAAS,EACT,QAAgB;IAEhB,MAAM,QAAQ,OAAO,WAAW,GAAG,IAAI;IACvC,MAAM,OAAO,WAAW,KAAK;IAE7B,IAAI;QAAC;QAAS;KAAU,CAAC,QAAQ,CAAC,QAAQ,OAAO;IACjD,IAAI,UAAU,YAAY;QACxB,MAAM,IAAI,IAAI,KAAK;QACnB,EAAE,OAAO,CAAC,EAAE,OAAO,KAAK;QACxB,OAAO;IACT;IACA,IAAI,MAAM,KAAK,CAAC,4BAA4B;QAC1C,MAAM,OAAO,SAAS,MAAM,KAAK,CAAC,SAAS,CAAC,EAAE,IAAI,KAAK;QACvD,MAAM,IAAI,IAAI,KAAK;QACnB,EAAE,UAAU,CAAC,EAAE,UAAU,KAAK;QAC9B,OAAO;IACT;IACA,IAAI,MAAM,KAAK,CAAC,+BAA+B;QAC7C,MAAM,MAAM,SAAS,MAAM,KAAK,CAAC,SAAS,CAAC,EAAE,IAAI,KAAK;QACtD,MAAM,IAAI,IAAI,KAAK;QACnB,EAAE,QAAQ,CAAC,EAAE,QAAQ,KAAK;QAC1B,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 1337, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/gemini.ts"],"sourcesContent":["// Gemini AI service for agent operations\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { getEnv } from './env';\nimport { parseJsonFromGemini } from '@automation/utils';\n\n// This will be used for all Gemini API calls\nexport class GeminiService {\n  private apiKey: string;\n  private genAI: GoogleGenerativeAI | null = null;\n\n  constructor() {\n    this.apiKey = getEnv('GEMINI_API_KEY') || '';\n\n    // Remove any surrounding quotes that might have been included\n    if (this.apiKey) {\n      this.apiKey = this.apiKey.trim().replace(/^[\"']|[\"']$/g, '');\n    }\n\n    if (!this.apiKey) {\n      console.error('GEMINI_API_KEY is not set in environment variables');\n    } else {\n      console.log('Gemini API key loaded, length:', this.apiKey.length);\n      try {\n        this.genAI = new GoogleGenerativeAI(this.apiKey);\n      } catch (error) {\n        console.error('Failed to initialize Google Generative AI:', error);\n      }\n    }\n  }\n\n  async generateContent(prompt: string, modelName: string = 'gemini-2.0-flash'): Promise<string> {\n    if (!this.genAI) {\n      throw new Error('Google Generative AI not initialized. Check your API key.');\n    }\n\n    // Try multiple model names in order of preference\n    // Reverting to gemini-2.0-flash as it was confirmed to exist (returned 403, not 404)\n    const modelNames = [\n      'gemini-2.5-flash'    // Standard fallback\n    ];\n\n    // Allow override via environment variable or parameter\n    const preferredModel = getEnv('GEMINI_MODEL') || modelName;\n    if (preferredModel && modelNames.includes(preferredModel)) {\n      modelNames.unshift(preferredModel);\n    }\n\n    let lastError: Error | null = null;\n    let attemptedModels: string[] = [];\n\n    for (const model of modelNames) {\n      try {\n        const genModel = this.genAI.getGenerativeModel({ model });\n        const result = await genModel.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n\n        // Silently succeed - no logging needed for normal operation\n        return text;\n      } catch (error: any) {\n        // Silently skip 404 errors (model not available) - these are expected when trying fallbacks\n        // Only track non-404 errors as they might indicate real problems\n        if (!error.message?.includes('404') && !error.message?.includes('Not Found')) {\n          console.warn(`Error with model ${model}:`, error.message);\n        }\n        attemptedModels.push(model);\n        lastError = error;\n        // Continue to next model\n        continue;\n      }\n    }\n\n    // If we get here, all models failed - log all attempted models\n    const errorMessage = `Failed to generate content with any available Gemini model. Attempted: ${attemptedModels.join(', ')}. Please check your API key and model availability.`;\n    console.error(errorMessage);\n    throw lastError || new Error(errorMessage);\n  }\n\n  generatePrompt(agentType: 'planner' | 'prioritization' | 'scheduler' | 'execution' | 'reflection', context: any): string {\n    switch (agentType) {\n      case 'planner':\n        return this.generatePlannerPrompt(context);\n      case 'prioritization':\n        return this.generatePrioritizationPrompt(context);\n      case 'scheduler':\n        return this.generateSchedulerPrompt(context);\n      case 'execution':\n        return this.generateExecutionPrompt(context);\n      case 'reflection':\n        return this.generateReflectionPrompt(context);\n      default:\n        throw new Error(`Unknown agent type: ${agentType}`);\n    }\n  }\n\n  private generatePlannerPrompt(context: any): string {\n    const memoryContext = context.memoryContext || {};\n    const similarItems = context.similarItems || [];\n    const originalInput = context.originalInput || context.goals.join(', ');\n\n    let memorySection = '';\n    if (memoryContext.existingPlans && memoryContext.existingPlans.length > 0) {\n      memorySection += `\\n\\nExisting Plans (for context, avoid duplication):\\n${memoryContext.existingPlans.slice(0, 5).map((plan: any) =>\n        `- \"${plan.title}\": ${plan.description} (Goal: ${plan.goal})`\n      ).join('\\n')}`;\n    }\n\n    if (memoryContext.relatedTasks && memoryContext.relatedTasks.length > 0) {\n      memorySection += `\\n\\nRelated Tasks (for context):\\n${memoryContext.relatedTasks.slice(0, 5).map((task: any) =>\n        `- \"${task.title}\": ${task.description || 'No description'}`\n      ).join('\\n')}`;\n    }\n\n    let duplicateWarning = '';\n    if (similarItems.length > 0) {\n      duplicateWarning = `\\n\\n DUPLICATE DETECTION: Similar items found:\\n${similarItems.map((item: any) =>\n        `- ${item.type === 'plan' ? 'Plan' : 'Task'}: \"${item.item.title}\" (${(item.similarity * 100).toFixed(0)}% similar) - ${item.reason}`\n      ).join('\\n')}\\n\\nIMPORTANT: If creating a new plan, ensure it's meaningfully different from the above. Consider merging or updating existing items instead.`;\n    }\n\n    return `You are a task planning AI assistant. Your job is to help users break down their goals into actionable tasks.\n\nUser Input: \"${originalInput}\"\nUser goals: ${context.goals.join(', ')}\nTime constraints: ${JSON.stringify(context.constraints)}\nExpected timeframe: ${context.timeframe ? `${context.timeframe.start} to ${context.timeframe.end}` : 'not specified'}${memorySection}${duplicateWarning}\n\nFIRST, generate a meaningful plan title and description from the user input:\n- Title: Should be concise (under 60 characters), descriptive, and capture the essence of the goal\n- Description: Should be a brief summary (under 200 characters) explaining what this plan aims to achieve\n\nTHEN, break down these goals into specific, actionable tasks. For each task, provide:\n1. A clear title (under 60 characters)\n2. A brief description (under 150 characters)\n3. Estimated time to complete (in minutes)\n4. Required focus level (shallow, medium, or deep)\n5. Energy requirement (low, medium, or high)\n6. Appropriate context (home, work, or anywhere)\n7. Relevant tags (max 3)\n8. kind: one of \"reminder\" (one-off time-based), \"todo\" (general actionable item), \"habit\" (recurring, no fixed time), \"daily\" (recurring daily)\n9. recurrencePerWeek: 1 for reminder/todo, 7 for daily, 3 for habit (times per week)\n\nReturn ONLY valid JSON. Do not wrap in markdown code blocks (no \\`\\`\\`).\nUse this structure:\n{\n  \"planTitle\": \"generated title from user input\",\n  \"planDescription\": \"generated description from user input\",\n  \"tasks\": [\n    {\n      \"title\": \"string\",\n      \"description\": \"string\",\n      \"estimatedTime\": number,\n      \"focusLevel\": \"shallow|medium|deep\",\n      \"energyRequirement\": \"low|medium|high\",\n      \"context\": \"home|work|anywhere\",\n      \"tags\": [\"tag1\", \"tag2\"],\n      \"kind\": \"reminder|todo|habit|daily\",\n      \"recurrencePerWeek\": number\n    }\n  ]\n}`;\n  }\n\n  private generatePrioritizationPrompt(context: any): string {\n    return `You are a task prioritization AI assistant. Your goal is to translate user priorities into a structured ranking while respecting temporal feasibility and human limitations.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Trust is preserved by predictability, not cleverness.\n- Explain your reasoning.\n\nCurrent Context:\n${context.currentContext ? `\n- Available time: ${context.currentContext.availableTime} minutes\n- Current energy level: ${context.currentContext.currentEnergy}\n- Current location: ${context.currentContext.location}\n- Available tools: ${context.currentContext.toolsAvailable.join(', ')}` : 'No specific context provided'}\n\nPlease analyze these tasks and rank them by priority. Consider:\n1. Deadline importance\n2. Long-term value\n3. Required focus level\n4. Energy cost\n5. Dependency complexity\n6. User preferences based on context\n\nTasks to prioritize:\n${JSON.stringify(context.tasks, null, 2)}\n\nReturn your response as JSON with an array of prioritized tasks and a brief summary of your reasoning:\n{\n  \"tasks\": [\n    {\n      \"id\": \"task_id\",\n      \"priorityScore\": number,\n      \"priority\": \"low|medium|high|urgent\",\n      \"reasoning\": \"brief explanation of priority score\"\n    }\n  ],\n  \"reasoning\": [\"point 1\", \"point 2\"]\n}`;\n  }\n\n  private generateSchedulerPrompt(context: any): string {\n    return `You are a task scheduling AI assistant. Your goal is to translate user goals into a realistic, temporally feasible schedule.\n\nPhilosophy:\n- Time is the governing dimension of the system.\n- Prefer fewer commitments and realistic schedules.\n- Always explain what you are about to do.\n- AI is a translator, not an authority.\n\nDate to schedule: ${context.date.toLocaleDateString()}\nEnergy profile: ${JSON.stringify(context.energyProfile)}\n${context.existingEvents ? `Existing events: ${JSON.stringify(context.existingEvents)}` : ''}\n${context.constraints ? `Constraints: ${JSON.stringify(context.constraints)}` : ''}\n\nTasks to schedule:\n${JSON.stringify(context.tasks, null, 2)}\n\nPlease create a Schedule for this date. Consider:\n1. User's energy profile (when their focus is strongest/weakest)\n2. Deep work session limits (max 2-3 sessions per day)\n3. Break time between deep work sessions (at least 15 minutes)\n4. Task focus levels and energy requirements\n5. Conflicts with existing events\n\nReturn your response as JSON with a schedule and reasoning:\n{\n  \"schedule\": {\n    \"date\": \"${context.date.toISOString()}\",\n    \"tasks\": [\n      {\n        \"taskId\": \"task_id\",\n        \"title\": \"task_title\",\n        \"scheduledStart\": \"ISO_datetime\",\n        \"scheduledEnd\": \"ISO_datetime\",\n        \"status\": \"scheduled\"\n      }\n    ],\n    \"reasoning\": [\"point 1\", \"point 2\"]\n  }\n}`;\n  }\n\n  private generateExecutionPrompt(context: any): string {\n    return `You are a task execution AI assistant. Your goal is to help users work on their current task by translating intent into concrete steps and identifying potential blockers.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Trust is preserved by predictability and clarity.\n- Reduce cognitive load by providing focused instructions.\n\nCurrent task: ${JSON.stringify(context.currentTask, null, 2)}\n${context.progress ? `Current progress: ${JSON.stringify(context.progress)}` : ''}\n${context.nextSteps ? `Next steps: ${context.nextSteps.join(', ')}` : ''}\n\nPlease provide:\n1. The absolute next step the user should take\n2. Clear instructions on how to complete this step\n3. Estimated time to complete this step\n4. Relevant context about related tasks and potential blockers\n5. Helpful suggestions for effective execution\n\nReturn your response as JSON:\n{\n  \"nextStep\": {\n    \"action\": \"string\",\n    \"instructions\": \"string\",\n    \"estimatedTime\": number,\n  },\n  \"context\": {\n    \"relatedTasks\": [\"task_id1\", \"task_id2\"],\n    \"blockers\": [\"blocker1\", \"blocker2\"],\n    \"resources\": [\"resource1\", \"resource2\"]\n  },\n  \"suggestions\": [\"suggestion1\", \"suggestion2\"]\n}`;\n  }\n\n  private generateReflectionPrompt(context: any): string {\n    return `You are a task reflection AI assistant. Your goal is to help users learn from their task completion patterns by providing non-authoritative advisory warnings and insights.\n\nPhilosophy:\n- Behavioral insights should be advisory, not authoritative.\n- Labels and warnings must be clear and skippable.\n- Focus on reducing cognitive load and increasing clarity.\n\nTasks being reflected on: ${JSON.stringify(context.tasks, null, 2)}\n${context.completionHistory.length > 0 ? `Task completion history: ${JSON.stringify(context.completionHistory, null, 2)}` : ''}\n${context.userFeedback && context.userFeedback.length > 0 ? `User feedback: ${JSON.stringify(context.userFeedback, null, 2)}` : ''}\n\nPlease analyze this data and provide:\n\n1. Behavioral patterns in task completion (time estimation accuracy, procrastination tendencies, etc.)\n2. Specific adjustments the user should make to their process\n3. Personalized recommendations for better task management\n\nReturn your response as JSON:\n{\n  \"insights\": {\n    \"patterns\": [\"pattern1\", \"pattern2\"],\n    \"adjustments\": [\n      {\n        \"type\": \"time|energy|priority|process\",\n        \"before\": \"current approach\",\n        \"after\": \"suggested approach\",\n        \"reason\": \"why this change would help\"\n      }\n    ]\n  },\n  \"recommendations\": [\"recommendation1\", \"recommendation2\"]\n}`;\n  }\n\n  async processVoiceTranscript(transcript: string, now: Date, timeZone: string) {\n    const prompt = `You are a voice-to-intent translator for a productivity system.\nYour goal is to split a messy voice transcript into logical chunks and classify each chunk.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Be conservative with intent detection.\n- Time is a first-class constraint. Normalize all time expressions relative to \"now\".\n\nCurrent \"Now\": ${now.toISOString()}\nCurrent Timezone: ${timeZone}\n\nTranscript: \"${transcript}\"\n\nSplit the transcript into logical chunks. For each chunk, determine:\n1. \"intent\": 'task' | 'reminder' | 'habit' | 'note' | 'unknown'\n2. \"normalized\": A cleaner version of the raw text.\n3. \"timeExpressions\": Array of normalized ISO-8601 timestamps found in the chunk, or relative time offsets.\n4. \"dueAt\": A single ISO-8601 timestamp representing the primary deadline or reminder time, if any.\n\nReturn your response as JSON with an array of chunks:\n{\n  \"chunks\": [\n    {\n      \"raw\": \"original segment\",\n      \"normalized\": \"clean version\",\n      \"intent\": \"task|reminder|habit|note|unknown\",\n      \"timeExpressions\": [\"ISO_timestamp\"],\n      \"dueAt\": \"ISO_timestamp or null\"\n    }\n  ]\n}`;\n\n    const response = await this.generateContent(prompt, 'gemini-1.5-flash');\n    try {\n      return parseJsonFromGemini(response);\n    } catch (error) {\n      console.error('Failed to parse Gemini response for voice transcript:', error);\n      return { chunks: [] };\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1678, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/memory-service.ts"],"sourcesContent":["import { taskRepo, planRepo, agentOutputRepo } from '@automation/data';\nimport { Task, Plan, AgentOutput } from '@automation/types';\nimport { GeminiService } from './gemini';\nimport { parseJsonFromGemini } from '@automation/utils';\n\nexport interface SimilarItem {\n  item: Task | Plan;\n  type: 'task' | 'plan';\n  similarity: number;\n  reason: string;\n}\n\nexport interface UserContext {\n  recentOutputs: AgentOutput[];\n  existingPlans: Plan[];\n  existingTasks: Task[];\n  recentInputs: string[];\n}\n\nexport class MemoryService {\n  private geminiService: GeminiService;\n\n  constructor() {\n    this.geminiService = new GeminiService();\n  }\n\n  /**\n   * Get comprehensive user context for memory-aware processing\n   */\n  async getUserContext(userId: string): Promise<UserContext> {\n    const [allPlans, allTasks, allOutputs] = await Promise.all([\n      planRepo.getAll(),\n      taskRepo.getAll(),\n      agentOutputRepo.getAll(),\n    ]);\n\n    // Filter to user's data (for now, we'll use all data since we don't have user filtering yet)\n    const userPlans = allPlans;\n    const userTasks = allTasks;\n    \n    // Get last 50 agent outputs (most recent first)\n    const recentOutputs = allOutputs\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n      .slice(0, 50);\n\n    // Extract recent user inputs from agent outputs\n    const recentInputs = recentOutputs\n      .map(output => {\n        if (output.input?.goals) {\n          return Array.isArray(output.input.goals) \n            ? output.input.goals.join(' ') \n            : output.input.goals;\n        }\n        if (output.input?.message) {\n          return output.input.message;\n        }\n        return null;\n      })\n      .filter((input): input is string => input !== null)\n      .slice(0, 20);\n\n    return {\n      recentOutputs,\n      existingPlans: userPlans,\n      existingTasks: userTasks,\n      recentInputs,\n    };\n  }\n\n  /**\n   * Find similar/duplicate items using semantic similarity\n   */\n  async findSimilarItems(\n    input: string,\n    userId: string,\n    threshold: number = 0.7\n  ): Promise<SimilarItem[]> {\n    const context = await this.getUserContext(userId);\n    const similarItems: SimilarItem[] = [];\n\n    // Use Gemini to analyze similarity\n    const prompt = `Analyze the following user input and compare it with existing plans and tasks to find duplicates or very similar items.\n\nUser Input: \"${input}\"\n\nExisting Plans:\n${context.existingPlans.map(plan => `- ID: ${plan.id}, Title: \"${plan.title}\", Description: \"${plan.description}\", Goal: \"${plan.goal}\"`).join('\\n')}\n\nExisting Tasks:\n${context.existingTasks.map(task => `- ID: ${task.id}, Title: \"${task.title}\", Description: \"${task.description || ''}\"`).join('\\n')}\n\nFor each existing item, determine:\n1. Similarity score (0-1, where 1 is identical/duplicate, 0.7+ is very similar)\n2. Reason for similarity\n\nReturn JSON array with format:\n{\n  \"similarItems\": [\n    {\n      \"id\": \"item_id\",\n      \"type\": \"plan\" or \"task\",\n      \"similarity\": 0.0-1.0,\n      \"reason\": \"brief explanation\"\n    }\n  ]\n}\n\nOnly include items with similarity >= ${threshold}.`;\n\n    try {\n      const response = await this.geminiService.generateContent(prompt);\n      const result = parseJsonFromGemini(response) as { similarItems?: Array<{ id: string; type: 'plan' | 'task'; similarity: number; reason?: string }> };\n      \n      if (result.similarItems && Array.isArray(result.similarItems)) {\n        for (const item of result.similarItems) {\n          const existingItem = item.type === 'plan'\n            ? context.existingPlans.find(p => p.id === item.id)\n            : context.existingTasks.find(t => t.id === item.id);\n          \n          if (existingItem && item.similarity >= threshold) {\n            similarItems.push({\n              item: existingItem,\n              type: item.type,\n              similarity: item.similarity,\n              reason: item.reason || 'Similar content found',\n            });\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error finding similar items:', error);\n      // Fallback to simple text matching\n      return this.fallbackSimilarityCheck(input, context, threshold);\n    }\n\n    // Sort by similarity (highest first)\n    return similarItems.sort((a, b) => b.similarity - a.similarity);\n  }\n\n  /**\n   * Fallback similarity check using simple text matching\n   */\n  private fallbackSimilarityCheck(\n    input: string,\n    context: UserContext,\n    threshold: number\n  ): SimilarItem[] {\n    const similarItems: SimilarItem[] = [];\n    const inputLower = input.toLowerCase();\n    const inputWords = inputLower.split(/\\s+/);\n\n    // Check plans\n    for (const plan of context.existingPlans) {\n      const planText = `${plan.title} ${plan.description} ${plan.goal}`.toLowerCase();\n      const planWords = planText.split(/\\s+/);\n      \n      // Calculate simple word overlap\n      const commonWords = inputWords.filter(word => \n        word.length > 3 && planWords.includes(word)\n      );\n      const similarity = commonWords.length / Math.max(inputWords.length, planWords.length);\n      \n      if (similarity >= threshold) {\n        similarItems.push({\n          item: plan,\n          type: 'plan',\n          similarity,\n          reason: `Shared ${commonWords.length} keywords: ${commonWords.slice(0, 3).join(', ')}`,\n        });\n      }\n    }\n\n    // Check tasks\n    for (const task of context.existingTasks) {\n      const taskText = `${task.title} ${task.description || ''}`.toLowerCase();\n      const taskWords = taskText.split(/\\s+/);\n      \n      const commonWords = inputWords.filter(word => \n        word.length > 3 && taskWords.includes(word)\n      );\n      const similarity = commonWords.length / Math.max(inputWords.length, taskWords.length);\n      \n      if (similarity >= threshold) {\n        similarItems.push({\n          item: task,\n          type: 'task',\n          similarity,\n          reason: `Shared ${commonWords.length} keywords: ${commonWords.slice(0, 3).join(', ')}`,\n        });\n      }\n    }\n\n    return similarItems;\n  }\n\n  /**\n   * Get contextually related items for enriching AI prompts\n   */\n  async getRelatedContext(\n    input: string,\n    userId: string\n  ): Promise<{\n    relatedPlans: Plan[];\n    relatedTasks: Task[];\n    relatedTags: string[];\n  }> {\n    const context = await this.getUserContext(userId);\n    const inputLower = input.toLowerCase();\n    const inputWords = inputLower.split(/\\s+/).filter(w => w.length > 3);\n\n    // Find plans with similar goals/tags\n    const relatedPlans = context.existingPlans.filter(plan => {\n      const planText = `${plan.title} ${plan.description} ${plan.goal}`.toLowerCase();\n      return inputWords.some(word => planText.includes(word));\n    });\n\n    // Find tasks with similar descriptions/tags\n    const relatedTasks = context.existingTasks.filter(task => {\n      const taskText = `${task.title} ${task.description || ''} ${task.tags.join(' ')}`.toLowerCase();\n      return inputWords.some(word => taskText.includes(word));\n    });\n\n    // Extract common tags\n    const allTags = new Set<string>();\n    relatedPlans.forEach(plan => {\n      // Plans don't have tags in the model, but we can extract from related tasks\n    });\n    relatedTasks.forEach(task => {\n      task.tags.forEach(tag => allTags.add(tag));\n    });\n\n    return {\n      relatedPlans: relatedPlans.slice(0, 5), // Limit to top 5\n      relatedTasks: relatedTasks.slice(0, 10), // Limit to top 10\n      relatedTags: Array.from(allTags).slice(0, 10),\n    };\n  }\n}\n\nexport const memoryService = new MemoryService();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1858, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/pressure-service.ts"],"sourcesContent":["import type { Task, Project, TaskKind } from \"@automation/types\";\n\nconst KINDS: TaskKind[] = [\"reminder\", \"todo\", \"habit\", \"daily\"];\n\nfunction defaultRecurrencePerWeek(kind: TaskKind): number {\n  switch (kind) {\n    case \"daily\":\n      return 7;\n    case \"habit\":\n      return 3;\n    case \"reminder\":\n    case \"todo\":\n    default:\n      return 1;\n  }\n}\n\n/** Current ISO week (MonSun) bounds. */\nexport function getWeekBounds(): { start: Date; end: Date } {\n  const now = new Date();\n  const day = now.getDay();\n  const diff = now.getDate() - day + (day === 0 ? -6 : 1);\n  const start = new Date(now);\n  start.setDate(diff);\n  start.setHours(0, 0, 0, 0);\n  const end = new Date(start);\n  end.setDate(start.getDate() + 6);\n  end.setHours(23, 59, 59, 999);\n  return { start, end };\n}\n\nfunction inWeek(d: Date, start: Date, end: Date): boolean {\n  const t = new Date(d).getTime();\n  return t >= start.getTime() && t <= end.getTime();\n}\n\nexport interface PressureResult {\n  totalHours: number;\n  projectHours: number;\n  nonProjectHours: number;\n  itemCount: number;\n  /** Non-project tasks + projects. Higher = more fragmented. */\n  fragmentation: \"low\" | \"medium\" | \"high\";\n  byKind: Record<TaskKind, { count: number; hours: number }>;\n  projects: { id: string; title: string; weeklyHours: number }[];\n}\n\n/**\n * Compute weekly pressure: hours from non-project tasks (reminder, todo, habit, daily)\n * plus project weekly allocations. Tasks in projects don't add timeproject hours count.\n * More hours + more split (items) = harder.\n */\nexport function computePressure(tasks: Task[], projects: Project[]): PressureResult {\n  const { start, end } = getWeekBounds();\n  const byKind: Record<TaskKind, { count: number; hours: number }> = {\n    reminder: { count: 0, hours: 0 },\n    todo: { count: 0, hours: 0 },\n    habit: { count: 0, hours: 0 },\n    daily: { count: 0, hours: 0 },\n  };\n\n  let nonProjectMinutes = 0;\n  let nonProjectItemCount = 0;\n\n  for (const t of tasks) {\n    if (t.status === \"cancelled\") continue;\n    const kind = (t.kind ?? \"todo\") as TaskKind;\n    if (!KINDS.includes(kind)) continue;\n    if (t.projectId) continue;\n\n    const perWeek = t.recurrencePerWeek ?? defaultRecurrencePerWeek(kind);\n    const minutes = t.estimatedTime * perWeek;\n    byKind[kind].hours += minutes / 60;\n    byKind[kind].count += 1;\n    nonProjectMinutes += minutes;\n    nonProjectItemCount += 1;\n  }\n\n  let projectHours = 0;\n  for (const p of projects) {\n    projectHours += p.weeklyHours;\n  }\n\n  const nonProjectHours = nonProjectMinutes / 60;\n  const totalHours = nonProjectHours + projectHours;\n  const itemCount = nonProjectItemCount + projects.length;\n\n  let fragmentation: \"low\" | \"medium\" | \"high\" = \"low\";\n  if (totalHours > 0) {\n    const itemsPer10h = itemCount / (totalHours / 10);\n    if (itemsPer10h >= 8 || itemCount >= 25) fragmentation = \"high\";\n    else if (itemsPer10h >= 4 || itemCount >= 12) fragmentation = \"medium\";\n  }\n\n  return {\n    totalHours,\n    projectHours,\n    nonProjectHours,\n    itemCount,\n    fragmentation,\n    byKind,\n    projects: projects.map((p) => ({ id: p.id, title: p.title, weeklyHours: p.weeklyHours })),\n  };\n}\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,QAAoB;IAAC;IAAY;IAAQ;IAAS;CAAQ;AAEhE,SAAS,yBAAyB,IAAc;IAC9C,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;QACL;YACE,OAAO;IACX;AACF;AAGO,SAAS;IACd,MAAM,MAAM,IAAI;IAChB,MAAM,MAAM,IAAI,MAAM;IACtB,MAAM,OAAO,IAAI,OAAO,KAAK,MAAM,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC;IACtD,MAAM,QAAQ,IAAI,KAAK;IACvB,MAAM,OAAO,CAAC;IACd,MAAM,QAAQ,CAAC,GAAG,GAAG,GAAG;IACxB,MAAM,MAAM,IAAI,KAAK;IACrB,IAAI,OAAO,CAAC,MAAM,OAAO,KAAK;IAC9B,IAAI,QAAQ,CAAC,IAAI,IAAI,IAAI;IACzB,OAAO;QAAE;QAAO;IAAI;AACtB;AAEA,SAAS,OAAO,CAAO,EAAE,KAAW,EAAE,GAAS;IAC7C,MAAM,IAAI,IAAI,KAAK,GAAG,OAAO;IAC7B,OAAO,KAAK,MAAM,OAAO,MAAM,KAAK,IAAI,OAAO;AACjD;AAkBO,SAAS,gBAAgB,KAAa,EAAE,QAAmB;IAChE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG;IACvB,MAAM,SAA6D;QACjE,UAAU;YAAE,OAAO;YAAG,OAAO;QAAE;QAC/B,MAAM;YAAE,OAAO;YAAG,OAAO;QAAE;QAC3B,OAAO;YAAE,OAAO;YAAG,OAAO;QAAE;QAC5B,OAAO;YAAE,OAAO;YAAG,OAAO;QAAE;IAC9B;IAEA,IAAI,oBAAoB;IACxB,IAAI,sBAAsB;IAE1B,KAAK,MAAM,KAAK,MAAO;QACrB,IAAI,EAAE,MAAM,KAAK,aAAa;QAC9B,MAAM,OAAQ,EAAE,IAAI,IAAI;QACxB,IAAI,CAAC,MAAM,QAAQ,CAAC,OAAO;QAC3B,IAAI,EAAE,SAAS,EAAE;QAEjB,MAAM,UAAU,EAAE,iBAAiB,IAAI,yBAAyB;QAChE,MAAM,UAAU,EAAE,aAAa,GAAG;QAClC,MAAM,CAAC,KAAK,CAAC,KAAK,IAAI,UAAU;QAChC,MAAM,CAAC,KAAK,CAAC,KAAK,IAAI;QACtB,qBAAqB;QACrB,uBAAuB;IACzB;IAEA,IAAI,eAAe;IACnB,KAAK,MAAM,KAAK,SAAU;QACxB,gBAAgB,EAAE,WAAW;IAC/B;IAEA,MAAM,kBAAkB,oBAAoB;IAC5C,MAAM,aAAa,kBAAkB;IACrC,MAAM,YAAY,sBAAsB,SAAS,MAAM;IAEvD,IAAI,gBAA2C;IAC/C,IAAI,aAAa,GAAG;QAClB,MAAM,cAAc,YAAY,CAAC,aAAa,EAAE;QAChD,IAAI,eAAe,KAAK,aAAa,IAAI,gBAAgB;aACpD,IAAI,eAAe,KAAK,aAAa,IAAI,gBAAgB;IAChE;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA,UAAU,SAAS,GAAG,CAAC,CAAC,IAAM,CAAC;gBAAE,IAAI,EAAE,EAAE;gBAAE,OAAO,EAAE,KAAK;gBAAE,aAAa,EAAE,WAAW;YAAC,CAAC;IACzF;AACF"}},
    {"offset": {"line": 1966, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/validation-service.ts"],"sourcesContent":["import { differenceInMinutes, isAfter, isBefore, format } from 'date-fns';\nimport {\n  ScheduledTask,\n  Task,\n  TimeBlock,\n  User,\n  ValidationIssue,\n  ValidationResult,\n  Project,\n} from '@automation/types';\nimport { computePressure } from './pressure-service';\n\ntype ScheduledLike = ScheduledTask | TimeBlock;\n\nexport class ValidationService {\n  /**\n   * Validate a proposed schedule before persistence.\n   * Returns blocking errors, warnings, and a human-friendly summary.\n   */\n  validateSchedule(params: {\n    tasks: Task[];\n    scheduled: ScheduledTask[];\n    events?: TimeBlock[];\n    user?: User;\n    date?: Date;\n  }): ValidationResult {\n    const issues: ValidationIssue[] = [];\n    const events = params.events ?? [];\n    const user = params.user;\n\n    // Hard conflicts: overlap between scheduled tasks and existing events\n    for (const taskBlock of params.scheduled) {\n      const conflict = events.find((evt) =>\n        this.overlaps(taskBlock, evt)\n      );\n      if (conflict) {\n        issues.push({\n          code: 'hard_conflict',\n          severity: 'error',\n          message: `Task ${taskBlock.taskId} overlaps ${conflict.type} (${this.rangeLabel(conflict)})`,\n          relatedIds: [taskBlock.taskId],\n          details: 'Hard overlap detected',\n        });\n      }\n    }\n\n    // Hard conflicts: overlapping scheduled tasks\n    const sorted = [...params.scheduled].sort(\n      (a, b) => a.scheduledStart.getTime() - b.scheduledStart.getTime()\n    );\n    for (let i = 0; i < sorted.length - 1; i++) {\n      if (this.overlaps(sorted[i], sorted[i + 1])) {\n        issues.push({\n          code: 'task_overlap',\n          severity: 'error',\n          message: `Tasks ${sorted[i].taskId} and ${sorted[i + 1].taskId} overlap (${this.rangeLabel(sorted[i])})`,\n          relatedIds: [sorted[i].taskId, sorted[i + 1].taskId],\n        });\n      }\n    }\n\n    // Semantic conflicts: deep work late night or beyond workday\n    for (const block of params.scheduled) {\n      const task = params.tasks.find((t) => t.id === block.taskId);\n      if (!task) continue;\n\n      const hour = block.scheduledStart.getHours();\n      if (task.focusLevel === 'deep' && (hour < 8 || hour >= 18)) {\n        issues.push({\n          code: 'semantic_energy_mismatch',\n          severity: 'warn',\n          message: `Deep work task \"${task.title}\" is scheduled outside typical focus hours`,\n          relatedIds: [task.id],\n        });\n      }\n\n      // Unrealistic duration check\n      const duration = differenceInMinutes(block.scheduledEnd, block.scheduledStart);\n      if (duration > 240) {\n        issues.push({\n          code: 'duration_exceeds_4h',\n          severity: 'warn',\n          message: `Task \"${task.title}\" is scheduled for ${duration} minutes; recommend splitting`,\n          relatedIds: [task.id],\n        });\n      }\n    }\n\n    // Cognitive load: total scheduled minutes vs. work window\n    const totalMinutes = params.scheduled.reduce(\n      (sum, t) => sum + differenceInMinutes(t.scheduledEnd, t.scheduledStart),\n      0\n    );\n    const workWindowMinutes = 8 * 60;\n    if (totalMinutes > workWindowMinutes) {\n      issues.push({\n        code: 'cognitive_overload',\n        severity: 'warn',\n        message: `Total scheduled time (${totalMinutes}m) exceeds standard work window (${workWindowMinutes}m).`,\n      });\n    }\n\n    // Physical feasibility: travel time/transition time (Semantic)\n    for (let i = 0; i < sorted.length - 1; i++) {\n      const first = sorted[i];\n      const second = sorted[i + 1];\n      const gap = differenceInMinutes(second.scheduledStart, first.scheduledEnd);\n      \n      if (gap < 5 && gap >= 0) {\n        issues.push({\n          code: 'insufficient_transition',\n          severity: 'warn',\n          message: `Back-to-back tasks without transition time: ${this.rangeLabel(first)} and ${this.rangeLabel(second)}`,\n          relatedIds: [first.taskId, second.taskId],\n        });\n      }\n\n      // Check for location changes (if location is available in metadata or context)\n      if (first.location && second.location && first.location !== second.location && gap < 30) {\n        issues.push({\n          code: 'location_conflict_travel',\n          severity: 'warn',\n          message: `Infeasible travel time between ${first.location} and ${second.location} (${gap}m gap)`,\n          relatedIds: [first.taskId, second.taskId],\n        });\n      }\n    }\n\n    // Time sanity: start before end\n    for (const block of params.scheduled) {\n      if (!isBefore(block.scheduledStart, block.scheduledEnd)) {\n        issues.push({\n          code: 'invalid_time_range',\n          severity: 'error',\n          message: `Task ${block.taskId} has an invalid time range`,\n          relatedIds: [block.taskId],\n        });\n      }\n    }\n\n    const blocking = issues.some((i) => i.severity === 'error');\n    const requiresConfirmation = issues.length > 0;\n\n    return {\n      ok: !blocking,\n      requiresConfirmation,\n      issues,\n      summary: this.buildSummary(issues, user),\n    };\n  }\n\n  /**\n   * Validate task input before creation/update.\n   * Enforces time presence, duration sanity, and dependency sanity.\n   */\n  validateTaskInput(params: {\n    task: Partial<Task>;\n    existing?: Task[];\n    projects?: Project[];\n  }): ValidationResult {\n    const { task, existing = [], projects = [] } = params;\n    const issues: ValidationIssue[] = [];\n\n    // Time is required for actionable items (todo/reminder). Habits/dailies can rely on recurrence.\n    const kind = task.kind ?? 'todo';\n    if (!task.dueDate && kind !== 'habit' && kind !== 'daily') {\n      issues.push({\n        code: 'time_missing',\n        severity: 'error',\n        message: 'A concrete time (due date or schedule) is required before committing the task.',\n      });\n    }\n\n    // Weekly Pressure Check\n    if (existing.length > 0) {\n      const currentPressure = computePressure(existing as Task[], projects);\n      if (currentPressure.totalHours > 40) {\n        issues.push({\n          code: 'weekly_overload',\n          severity: 'warn',\n          message: `Weekly workload is high (${currentPressure.totalHours.toFixed(1)}h). Consider deferring this task.`,\n        });\n      }\n    }\n\n    // Estimated time sanity\n    if (typeof task.estimatedTime === 'number' && task.estimatedTime <= 0) {\n      issues.push({\n        code: 'invalid_estimate',\n        severity: 'error',\n        message: 'Estimated time must be greater than zero minutes.',\n      });\n    }\n    if (typeof task.estimatedTime === 'number' && task.estimatedTime > 480) {\n      issues.push({\n        code: 'estimate_exceeds_day',\n        severity: 'warn',\n        message: 'Estimated time exceeds a full workday; consider splitting the task.',\n      });\n    }\n\n    // Dependency sanity\n    if (task.dependencies && task.dependencies.length) {\n      const missing = task.dependencies.filter(\n        (dep) => !existing.find((t) => t.id === dep)\n      );\n      if (missing.length) {\n        issues.push({\n          code: 'dependency_missing',\n          severity: 'error',\n          message: `Dependencies not found: ${missing.join(', ')}`,\n          relatedIds: missing,\n        });\n      }\n    }\n\n    return {\n      ok: !issues.some((i) => i.severity === 'error'),\n      requiresConfirmation: issues.length > 0,\n      issues,\n      summary: this.buildSummary(issues),\n    };\n  }\n\n  private overlaps(a: ScheduledLike, b: ScheduledLike): boolean {\n    const startA = 'scheduledStart' in a ? a.scheduledStart : a.start;\n    const endA = 'scheduledEnd' in a ? a.scheduledEnd : a.end;\n    const startB = 'scheduledStart' in b ? b.scheduledStart : b.start;\n    const endB = 'scheduledEnd' in b ? b.scheduledEnd : b.end;\n    return isBefore(startA, endB) && isAfter(endA, startB);\n  }\n\n  private buildSummary(issues: ValidationIssue[], user?: User): string[] {\n    if (!issues.length) return ['Validation passed  no conflicts detected'];\n    const blocking = issues.filter((i) => i.severity === 'error').length;\n    const warnings = issues.filter((i) => i.severity === 'warn').length;\n\n    const summary: string[] = [\n      `${blocking} blocking issue(s), ${warnings} warning(s) detected`,\n    ];\n\n    const top = issues.slice(0, 5).map((i) => `${i.severity.toUpperCase()}: ${i.message}`);\n    summary.push(...top);\n\n    if (user?.preferences?.notificationSettings?.scheduleChanges) {\n      summary.push('User notifications enabled: schedule changes should be summarized before send.');\n    }\n\n    return summary;\n  }\n\n  private rangeLabel(block: ScheduledLike): string {\n    const start = 'scheduledStart' in block ? block.scheduledStart : block.start;\n    const end = 'scheduledEnd' in block ? block.scheduledEnd : block.end;\n    return `${start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}${end.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;\n  }\n}\n\nexport const validationService = new ValidationService();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2207, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/notification-guard.ts"],"sourcesContent":["import { differenceInMinutes } from 'date-fns';\n\ninterface NotificationPayload {\n  title: string;\n  body: string;\n  data?: Record<string, string>;\n  priority?: 'normal' | 'high';\n}\n\ninterface NotificationContext {\n  lastSentAt?: Date;\n  minIntervalMinutes?: number;\n  channel?: 'task' | 'schedule' | 'summary' | 'system';\n}\n\nexport class NotificationGuard {\n  /**\n   * Validate and annotate a push notification before sending.\n   * Enforces explicit, meaningful, non-spammy rules from App_system.\n   */\n  validate(payload: NotificationPayload, ctx: NotificationContext = {}) {\n    const issues: string[] = [];\n\n    if (!payload.title || !payload.body) {\n      issues.push('Notification must include title and body.');\n    }\n\n    // Semantic quality checks\n    if (payload.body.length < 8) {\n      issues.push('Notification body is too short to be meaningful.');\n    }\n\n    // Rate limiting\n    const minInterval = ctx.minIntervalMinutes ?? 15;\n    if (ctx.lastSentAt) {\n      const minutesSinceLast = differenceInMinutes(new Date(), ctx.lastSentAt);\n      if (minutesSinceLast < minInterval) {\n        issues.push(`Last notification sent ${minutesSinceLast}m ago; wait at least ${minInterval}m to avoid spam.`);\n      }\n    }\n\n    return {\n      ok: issues.length === 0,\n      issues,\n      recommendation: 'Send only after user-visible confirmation for high-priority or back-to-back messages.',\n    };\n  }\n}\n\nexport const notificationGuard = new NotificationGuard();\n"],"names":[],"mappings":";;;;;;AAAA;;AAeO,MAAM;IACX;;;GAGC,GACD,SAAS,OAA4B,EAAE,MAA2B,CAAC,CAAC,EAAE;QACpE,MAAM,SAAmB,EAAE;QAE3B,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,IAAI,EAAE;YACnC,OAAO,IAAI,CAAC;QACd;QAEA,0BAA0B;QAC1B,IAAI,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG;YAC3B,OAAO,IAAI,CAAC;QACd;QAEA,gBAAgB;QAChB,MAAM,cAAc,IAAI,kBAAkB,IAAI;QAC9C,IAAI,IAAI,UAAU,EAAE;YAClB,MAAM,mBAAmB,IAAA,oOAAmB,EAAC,IAAI,QAAQ,IAAI,UAAU;YACvE,IAAI,mBAAmB,aAAa;gBAClC,OAAO,IAAI,CAAC,CAAC,uBAAuB,EAAE,iBAAiB,qBAAqB,EAAE,YAAY,gBAAgB,CAAC;YAC7G;QACF;QAEA,OAAO;YACL,IAAI,OAAO,MAAM,KAAK;YACtB;YACA,gBAAgB;QAClB;IACF;AACF;AAEO,MAAM,oBAAoB,IAAI"}},
    {"offset": {"line": 2248, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/voice-intake.ts"],"sourcesContent":["/**\n * Voice intake helper: chunks messy speech into logical units and classifies each\n * into intents (task, reminder, habit, note) with lightweight heuristics.\n * Designed to be paired with LLM refinement but provides deterministic fallbacks.\n */\nimport { GeminiService } from './gemini';\n\nexport type VoiceChunkIntent = 'task' | 'reminder' | 'habit' | 'note' | 'unknown';\n\nexport interface VoiceChunk {\n  raw: string;\n  normalized: string;\n  intent: VoiceChunkIntent;\n  timeExpressions: string[];\n  dueAt?: string | null;\n}\n\nexport class VoiceIntakeService {\n  private geminiService = new GeminiService();\n\n  /**\n   * Processes a transcript using LLM for high-quality intent extraction and temporal normalization.\n   * Falls back to deterministic heuristics if LLM fails or is unavailable.\n   */\n  async process(transcript: string, now: Date = new Date(), timeZone: string = 'UTC'): Promise<VoiceChunk[]> {\n    try {\n      const result = await this.geminiService.processVoiceTranscript(\n        transcript,\n        now,\n        timeZone\n      ) as { chunks?: VoiceChunk[] };\n      if (result && Array.isArray(result.chunks)) {\n        return result.chunks;\n      }\n    } catch (error) {\n      console.error('LLM voice processing failed, falling back to heuristics:', error);\n    }\n\n    return this.splitAndClassifyHeuristic(transcript);\n  }\n\n  splitAndClassifyHeuristic(transcript: string): VoiceChunk[] {\n    // Naive sentence segmentation; in production use a proper NLP splitter.\n    const sentences = transcript\n      .split(/(?<=[.!?])\\s+/)\n      .map(s => s.trim())\n      .filter(Boolean);\n\n    return sentences.map(sentence => {\n      const normalized = sentence.toLowerCase();\n      const intent = this.detectIntent(normalized);\n      const timeExpressions = this.extractTime(normalized);\n      return { raw: sentence, normalized, intent, timeExpressions };\n    });\n  }\n\n  private detectIntent(text: string): VoiceChunkIntent {\n    if (text.includes('every day') || text.includes('daily')) return 'habit';\n    if (text.startsWith('remind') || text.includes('remind me')) return 'reminder';\n    if (text.includes('note') || text.startsWith('note to self')) return 'note';\n    if (text.includes('task') || text.includes('todo') || text.includes('to do')) return 'task';\n    return 'unknown';\n  }\n\n  private extractTime(text: string): string[] {\n    const matches = text.match(/\\b(today|tomorrow|monday|tuesday|wednesday|thursday|friday|saturday|sunday|\\d{1,2}(:\\d{2})?\\s?(am|pm)?|\\d{4}-\\d{2}-\\d{2})\\b/gi);\n    return matches ? matches : [];\n  }\n}\n\nexport const voiceIntakeService = new VoiceIntakeService();\n"],"names":[],"mappings":";;;;;;AAAA;;;;CAIC,GACD;;AAYO,MAAM;IACH,gBAAgB,IAAI,wJAAa,GAAG;IAE5C;;;GAGC,GACD,MAAM,QAAQ,UAAkB,EAAE,MAAY,IAAI,MAAM,EAAE,WAAmB,KAAK,EAAyB;QACzG,IAAI;YACF,MAAM,SAAS,MAAM,IAAI,CAAC,aAAa,CAAC,sBAAsB,CAC5D,YACA,KACA;YAEF,IAAI,UAAU,MAAM,OAAO,CAAC,OAAO,MAAM,GAAG;gBAC1C,OAAO,OAAO,MAAM;YACtB;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4DAA4D;QAC5E;QAEA,OAAO,IAAI,CAAC,yBAAyB,CAAC;IACxC;IAEA,0BAA0B,UAAkB,EAAgB;QAC1D,wEAAwE;QACxE,MAAM,YAAY,WACf,KAAK,CAAC,iBACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,IACf,MAAM,CAAC;QAEV,OAAO,UAAU,GAAG,CAAC,CAAA;YACnB,MAAM,aAAa,SAAS,WAAW;YACvC,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC;YACjC,MAAM,kBAAkB,IAAI,CAAC,WAAW,CAAC;YACzC,OAAO;gBAAE,KAAK;gBAAU;gBAAY;gBAAQ;YAAgB;QAC9D;IACF;IAEQ,aAAa,IAAY,EAAoB;QACnD,IAAI,KAAK,QAAQ,CAAC,gBAAgB,KAAK,QAAQ,CAAC,UAAU,OAAO;QACjE,IAAI,KAAK,UAAU,CAAC,aAAa,KAAK,QAAQ,CAAC,cAAc,OAAO;QACpE,IAAI,KAAK,QAAQ,CAAC,WAAW,KAAK,UAAU,CAAC,iBAAiB,OAAO;QACrE,IAAI,KAAK,QAAQ,CAAC,WAAW,KAAK,QAAQ,CAAC,WAAW,KAAK,QAAQ,CAAC,UAAU,OAAO;QACrF,OAAO;IACT;IAEQ,YAAY,IAAY,EAAY;QAC1C,MAAM,UAAU,KAAK,KAAK,CAAC;QAC3B,OAAO,UAAU,UAAU,EAAE;IAC/B;AACF;AAEO,MAAM,qBAAqB,IAAI"}},
    {"offset": {"line": 2308, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/email-service.ts"],"sourcesContent":["export interface EmailDraft {\n  to: string[];\n  subject: string;\n  body: string;\n  cc?: string[];\n  bcc?: string[];\n}\n\nexport interface EmailSendOptions {\n  confirmed: boolean; // must be true to actually send\n  dryRun?: boolean; // when true, return payload only\n}\n\n/**\n * Email service stub that enforces explicit preview/confirmation before send.\n * Integrate with provider (e.g., Resend, SES) where indicated.\n */\nexport class EmailService {\n  async preview(draft: EmailDraft) {\n    return {\n      draft,\n      summary: `Ready to send to ${draft.to.join(', ')}`,\n      requiresConfirmation: true,\n    };\n  }\n\n  async send(draft: EmailDraft, options: EmailSendOptions) {\n    if (!options.confirmed) {\n      return {\n        sent: false,\n        requiresConfirmation: true,\n        message: 'Confirmation required before sending email.',\n        draft,\n      };\n    }\n\n    // TODO: plug in real email provider here.\n    if (options.dryRun) {\n      return { sent: false, dryRun: true, payload: draft };\n    }\n\n    // Placeholder success response\n    return { sent: true, id: `email_${Date.now()}`, draft };\n  }\n}\n\nexport const emailService = new EmailService();\n"],"names":[],"mappings":";;;;;;AAiBO,MAAM;IACX,MAAM,QAAQ,KAAiB,EAAE;QAC/B,OAAO;YACL;YACA,SAAS,CAAC,iBAAiB,EAAE,MAAM,EAAE,CAAC,IAAI,CAAC,OAAO;YAClD,sBAAsB;QACxB;IACF;IAEA,MAAM,KAAK,KAAiB,EAAE,OAAyB,EAAE;QACvD,IAAI,CAAC,QAAQ,SAAS,EAAE;YACtB,OAAO;gBACL,MAAM;gBACN,sBAAsB;gBACtB,SAAS;gBACT;YACF;QACF;QAEA,0CAA0C;QAC1C,IAAI,QAAQ,MAAM,EAAE;YAClB,OAAO;gBAAE,MAAM;gBAAO,QAAQ;gBAAM,SAAS;YAAM;QACrD;QAEA,+BAA+B;QAC/B,OAAO;YAAE,MAAM;YAAM,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI;YAAE;QAAM;IACxD;AACF;AAEO,MAAM,eAAe,IAAI"}},
    {"offset": {"line": 2352, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/clickup-service.ts"],"sourcesContent":["export interface ClickUpTaskPayload {\n  name: string;\n  description?: string;\n  status?: string;\n  priority?: number;\n  due_date?: number;\n  time_estimate?: number;\n  tags?: string[];\n  assignees?: string[];\n}\n\nexport interface SyncOptions {\n  allowOverride?: boolean;\n  dryRun?: boolean;\n}\n\n/**\n * ClickUp integration stub with explicit mapping and override controls.\n * Real API calls should respect `allowOverride` and surface a preview before sync.\n */\nexport class ClickUpService {\n  mapTaskToClickUp(task: any): ClickUpTaskPayload {\n    return {\n      name: task.title,\n      description: task.description,\n      status: task.status,\n      priority: this.mapPriority(task.priority),\n      due_date: task.dueDate ? new Date(task.dueDate).getTime() : undefined,\n      time_estimate: task.estimatedTime ? task.estimatedTime * 60000 : undefined,\n      tags: task.tags,\n    };\n  }\n\n  async previewSync(task: any) {\n    const payload = this.mapTaskToClickUp(task);\n    return {\n      payload,\n      requiresConfirmation: true,\n      summary: `Will create/update ClickUp task: \"${payload.name}\" with priority ${payload.priority || 'default'}.`,\n      note: 'AI is a translator; review this mapping before it becomes an authority in ClickUp.',\n    };\n  }\n\n  async syncTask(task: any, options: SyncOptions = {}) {\n    const payload = this.mapTaskToClickUp(task);\n\n    if (!options.allowOverride) {\n      return {\n        synced: false,\n        requiresConfirmation: true,\n        message: 'ClickUp sync requires explicit user confirmation (Philosophy 2.1).',\n        payload,\n      };\n    }\n\n    if (options.dryRun) {\n      return { synced: false, dryRun: true, payload };\n    }\n\n    // TODO: call ClickUp API here\n    return { synced: true, payload, id: `clickup_${Date.now()}` };\n  }\n\n  private mapPriority(priority: string | undefined) {\n    switch (priority) {\n      case 'urgent': return 1;\n      case 'high': return 2;\n      case 'medium': return 3;\n      case 'low': return 4;\n      default: return undefined;\n    }\n  }\n}\n\nexport const clickUpService = new ClickUpService();\n"],"names":[],"mappings":";;;;;;AAoBO,MAAM;IACX,iBAAiB,IAAS,EAAsB;QAC9C,OAAO;YACL,MAAM,KAAK,KAAK;YAChB,aAAa,KAAK,WAAW;YAC7B,QAAQ,KAAK,MAAM;YACnB,UAAU,IAAI,CAAC,WAAW,CAAC,KAAK,QAAQ;YACxC,UAAU,KAAK,OAAO,GAAG,IAAI,KAAK,KAAK,OAAO,EAAE,OAAO,KAAK;YAC5D,eAAe,KAAK,aAAa,GAAG,KAAK,aAAa,GAAG,QAAQ;YACjE,MAAM,KAAK,IAAI;QACjB;IACF;IAEA,MAAM,YAAY,IAAS,EAAE;QAC3B,MAAM,UAAU,IAAI,CAAC,gBAAgB,CAAC;QACtC,OAAO;YACL;YACA,sBAAsB;YACtB,SAAS,CAAC,kCAAkC,EAAE,QAAQ,IAAI,CAAC,gBAAgB,EAAE,QAAQ,QAAQ,IAAI,UAAU,CAAC,CAAC;YAC7G,MAAM;QACR;IACF;IAEA,MAAM,SAAS,IAAS,EAAE,UAAuB,CAAC,CAAC,EAAE;QACnD,MAAM,UAAU,IAAI,CAAC,gBAAgB,CAAC;QAEtC,IAAI,CAAC,QAAQ,aAAa,EAAE;YAC1B,OAAO;gBACL,QAAQ;gBACR,sBAAsB;gBACtB,SAAS;gBACT;YACF;QACF;QAEA,IAAI,QAAQ,MAAM,EAAE;YAClB,OAAO;gBAAE,QAAQ;gBAAO,QAAQ;gBAAM;YAAQ;QAChD;QAEA,8BAA8B;QAC9B,OAAO;YAAE,QAAQ;YAAM;YAAS,IAAI,CAAC,QAAQ,EAAE,KAAK,GAAG,IAAI;QAAC;IAC9D;IAEQ,YAAY,QAA4B,EAAE;QAChD,OAAQ;YACN,KAAK;gBAAU,OAAO;YACtB,KAAK;gBAAQ,OAAO;YACpB,KAAK;gBAAU,OAAO;YACtB,KAAK;gBAAO,OAAO;YACnB;gBAAS,OAAO;QAClB;IACF;AACF;AAEO,MAAM,iBAAiB,IAAI"}},
    {"offset": {"line": 2483, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/groq.ts"],"sourcesContent":["import Groq from 'groq-sdk';\nimport { getEnv } from './env';\n\nexport class GroqService {\n  private client: Groq;\n\n  constructor() {\n    this.client = new Groq({\n      apiKey: getEnv('GROQ_API_KEY') || '',\n    });\n  }\n\n  async transcribe(file: File | Blob): Promise<string> {\n    try {\n      // Groq SDK accepts File objects directly\n      // If we have a Blob, convert it to a File\n      let audioFile: File;\n      if (file instanceof File) {\n        audioFile = file;\n      } else {\n        // Convert Blob to File\n        audioFile = new File([file], 'audio.webm', { \n          type: file.type || 'audio/webm' \n        });\n      }\n\n      // The Groq SDK for Node.js accepts File objects directly\n      // It will handle the file reading internally\n      const transcription = await this.client.audio.transcriptions.create({\n        file: audioFile,\n        model: 'whisper-large-v3-turbo',\n        temperature: 0,\n        response_format: 'verbose_json',\n      });\n\n      return transcription.text;\n    } catch (error) {\n      console.error('Error in Groq transcription service:', error);\n      throw error;\n    }\n  }\n}\n\nexport const groqService = new GroqService();\nexport default GroqService;\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEO,MAAM;IACH,OAAa;IAErB,aAAc;QACZ,IAAI,CAAC,MAAM,GAAG,IAAI,0MAAI,CAAC;YACrB,QAAQ,IAAA,8IAAM,EAAC,mBAAmB;QACpC;IACF;IAEA,MAAM,WAAW,IAAiB,EAAmB;QACnD,IAAI;YACF,yCAAyC;YACzC,0CAA0C;YAC1C,IAAI;YACJ,IAAI,gBAAgB,MAAM;gBACxB,YAAY;YACd,OAAO;gBACL,uBAAuB;gBACvB,YAAY,IAAI,KAAK;oBAAC;iBAAK,EAAE,cAAc;oBACzC,MAAM,KAAK,IAAI,IAAI;gBACrB;YACF;YAEA,yDAAyD;YACzD,6CAA6C;YAC7C,MAAM,gBAAgB,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC;gBAClE,MAAM;gBACN,OAAO;gBACP,aAAa;gBACb,iBAAiB;YACnB;YAEA,OAAO,cAAc,IAAI;QAC3B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wCAAwC;YACtD,MAAM;QACR;IACF;AACF;AAEO,MAAM,cAAc,IAAI;uCAChB"}},
    {"offset": {"line": 2538, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/services/src/index.ts"],"sourcesContent":["// Export all services\nexport { GeminiService } from './gemini';\nexport { memoryService, MemoryService } from './memory-service';\nexport { computePressure, getWeekBounds } from './pressure-service';\nexport type { PressureResult } from './pressure-service';\nexport type { SimilarItem, UserContext } from './memory-service';\nexport { validationService, ValidationService } from './validation-service';\nexport { notificationGuard, NotificationGuard } from './notification-guard';\nexport { voiceIntakeService, VoiceIntakeService } from './voice-intake';\nexport { emailService, EmailService } from './email-service';\nexport { clickUpService, ClickUpService } from './clickup-service';\n\n// Export environment utilities\nexport { getEnv, requireEnv } from './env';\n\n// Re-export groq if needed\nexport * from './groq';\n"],"names":[],"mappings":";AAAA,sBAAsB;AACtB;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA,+BAA+B;AAC/B;AAEA,2BAA2B;AAC3B"}},
    {"offset": {"line": 2566, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/planner-agent.ts"],"sourcesContent":["import { Task, Plan, ValidationResult } from '@automation/types';\nimport {\n  BaseAgent,\n  BaseAgentOutput,\n  PlannerInput,\n  PlannerOutput,\n  BaseAgentInput\n} from './base-agent';\nimport { taskRepo, planRepo, userRepo } from '@automation/data';\nimport { GeminiService, memoryService, SimilarItem, validationService } from '@automation/services';\nimport { parseJsonFromGemini } from '@automation/utils';\n\nexport class PlannerAgent implements BaseAgent<PlannerInput, PlannerOutput> {\n  type = 'planner';\n\n  async process(input: PlannerInput): Promise<BaseAgentOutput> {\n    const { user, goals, constraints, timeframe } = input;\n    const reasoning: string[] = [];\n    const originalInput = goals.join(' ');\n    const forceCreate = (input as any).forceCreate || false;\n\n    try {\n      // Step 1: Load memory context\n      const memoryContext = await memoryService.getUserContext(user.id);\n      reasoning.push(`Loaded context: ${memoryContext.existingPlans.length} plans, ${memoryContext.existingTasks.length} tasks`);\n\n      // Step 2: Check for duplicates/similar items (skip if forceCreate is true)\n      let similarItems: SimilarItem[] = [];\n      if (!forceCreate) {\n        similarItems = await memoryService.findSimilarItems(originalInput, user.id, 0.7);\n      }\n      \n      if (similarItems.length > 0) {\n        const highestSimilarity = similarItems[0].similarity;\n        reasoning.push(`Found ${similarItems.length} similar items (highest similarity: ${(highestSimilarity * 100).toFixed(0)}%)`);\n        \n        // If very similar (>= 0.9), suggest merge/update\n        if (highestSimilarity >= 0.9) {\n          return {\n            result: {\n              plan: null,\n              tasks: [],\n              reasoning: [`Duplicate detected: ${similarItems[0].item.title} (${(highestSimilarity * 100).toFixed(0)}% similar)`],\n              duplicateItems: similarItems,\n              requiresConfirmation: true,\n            } as any,\n            confidence: 0.9,\n            metadata: { \n              duplicateDetected: true,\n              similarItems: similarItems.map(item => ({\n                id: item.item.id,\n                type: item.type,\n                title: item.item.title,\n                similarity: item.similarity,\n                reason: item.reason,\n              })),\n            },\n          };\n        }\n      }\n\n      // Step 3: Get related context for enrichment\n      const relatedContext = await memoryService.getRelatedContext(originalInput, user.id);\n      reasoning.push(`Found ${relatedContext.relatedPlans.length} related plans, ${relatedContext.relatedTasks.length} related tasks`);\n\n      // Step 4: Use Gemini to generate plan title, description, and tasks\n      const geminiService = new GeminiService();\n      const prompt = geminiService.generatePrompt('planner', { \n        goals, \n        constraints, \n        originalInput,\n        timeframe: timeframe ? {\n          start: timeframe.start.toISOString(), \n          end: timeframe.end.toISOString()\n        } : undefined,\n        memoryContext: {\n          existingPlans: memoryContext.existingPlans.slice(0, 5),\n          relatedTasks: relatedContext.relatedTasks,\n        },\n        similarItems: similarItems.slice(0, 3),\n      });\n      \n      const geminiResponse = await geminiService.generateContent(prompt);\n      let parsedResponse: { planTitle?: string; planDescription?: string; tasks?: unknown[] };\n      try {\n        parsedResponse = parseJsonFromGemini(geminiResponse) as typeof parsedResponse;\n      } catch (parseError) {\n        console.error('Failed to parse Gemini response:', geminiResponse);\n        throw new Error('Failed to parse AI response. Please try again.');\n      }\n      \n      const { planTitle, planDescription, tasks: geminiTasks } = parsedResponse;\n      \n      if (!geminiTasks || !Array.isArray(geminiTasks)) {\n        console.error('Invalid Gemini response structure:', parsedResponse);\n        throw new Error('AI returned invalid task structure. Please try again.');\n      }\n      \n      // Step 5: Build draft tasks (no persistence yet)\n      const taskDrafts = this.buildTaskDraftsFromGemini(geminiTasks, goals, timeframe);\n\n      // Step 6: Validate drafts pre-commit\n      const validationResults = taskDrafts.map(draft => ({\n        draft,\n        validation: validationService.validateTaskInput({\n          task: draft,\n          existing: memoryContext.existingTasks,\n          projects: memoryContext.existingPlans as any // Mapping plans to projects for pressure calculation\n        })\n      }));\n\n      const mergedValidation = this.mergeValidation(validationResults.map(v => v.validation));\n      const hasBlocking = mergedValidation.issues.some(issue => issue.severity === 'error');\n      const needsConfirmation = mergedValidation.requiresConfirmation || !input.confirm;\n\n      if (hasBlocking || needsConfirmation) {\n        reasoning.push(hasBlocking ? 'Validation blocked plan creation' : 'Validation requires user confirmation');\n        return {\n          result: {\n            plan: null,\n            tasks: [],\n            reasoning,\n            requiresConfirmation: true,\n            validation: mergedValidation,\n            draftTasks: taskDrafts\n          } as PlannerOutput,\n          confidence: hasBlocking ? 0.2 : 0.55,\n          metadata: {\n            validation: mergedValidation,\n            similarItemsFound: similarItems.length,\n            draftTaskCount: taskDrafts.length\n          }\n        };\n      }\n\n      // Step 7: Persist plan and tasks after validation & confirmation\n      const planId = await this.createPlan(\n        user.id, \n        goals, \n        constraints, \n        timeframe,\n        planTitle || `${goals[0]} - Generated Plan`,\n        planDescription || `Plan to achieve: ${goals.join(', ')}`\n      );\n      const plan = await planRepo.getById(planId);\n      \n      if (!plan) {\n        return {\n          result: null,\n          confidence: 0,\n          metadata: { error: 'Failed to create plan' }\n        };\n      }\n\n      const tasks = await this.createTasksFromDrafts(taskDrafts, plan.id);\n      \n      // Update plan with task IDs\n      const taskIds = tasks.map(task => task.id);\n      await planRepo.update(plan.id, { tasks: taskIds });\n      \n      reasoning.push(`Generated plan title: \"${plan.title}\"`);\n      reasoning.push(`Generated plan description: \"${plan.description}\"`);\n      reasoning.push(`Analyzed ${goals.length} goals and created ${tasks.length} tasks using AI`);\n      reasoning.push(`Estimated total effort: ${tasks.reduce((sum, task) => sum + task.estimatedTime, 0)} minutes`);\n      \n      // Record agent output for reflection\n      await this.recordAgentOutput(input, { plan, tasks, reasoning });\n\n      return {\n        result: { plan, tasks, reasoning } as PlannerOutput,\n        confidence: 0.85, // Higher confidence with AI assistance\n        metadata: { \n          planId: plan.id, \n          taskCount: tasks.length,\n          similarItemsFound: similarItems.length,\n          validation: mergedValidation\n        }\n      };\n    } catch (error: any) {\n      console.error('Error in Planner agent:', error);\n      console.error('Error stack:', error?.stack);\n      console.error('Error message:', error?.message);\n      return {\n        result: null,\n        confidence: 0,\n        metadata: { \n          error: error?.message || 'Unknown error in planner agent',\n          errorDetails: error?.stack,\n        }\n      };\n    }\n  }\n\n  private async createPlan(\n    userId: string, \n    goals: string[], \n    constraints: any, \n    timeframe?: { start: Date; end: Date },\n    title?: string,\n    description?: string\n  ): Promise<string> {\n    const plan = await planRepo.create({\n      title: title || `${goals[0]} - Generated Plan`,\n      description: description || `Plan to achieve: ${goals.join(', ')}`,\n      status: 'draft',\n      tasks: [], // Will be populated later\n      goal: goals[0],\n      constraints: constraints || {},\n      startDate: timeframe?.start,\n      endDate: timeframe?.end\n    });\n\n    return plan.id;\n  }\n\n  private buildTaskDraftsFromGemini(\n    geminiTasks: any[],\n    goals: string[],\n    timeframe?: { start: Date; end: Date }\n  ): Array<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>> {\n    return geminiTasks.map((geminiTask, idx) => ({\n      title: geminiTask.title || `Task ${idx + 1} for ${goals[0]}`,\n      description: geminiTask.description || '',\n      status: 'pending',\n      priority: geminiTask.priority || 'medium',\n      estimatedTime: geminiTask.estimatedTime || 30,\n      focusLevel: geminiTask.focusLevel || 'medium',\n      energyRequirement: geminiTask.energyRequirement || 'medium',\n      context: geminiTask.context || '',\n      subtasks: [],\n      dependencies: geminiTask.dependencies || [],\n      tags: geminiTask.tags || [],\n      parentTaskId: undefined, // will be set on persistence\n      kind: (geminiTask.kind || 'todo') as Task['kind'],\n      projectId: geminiTask.projectId ?? undefined,\n      recurrencePerWeek: geminiTask.recurrencePerWeek ?? undefined,\n      dueDate: geminiTask.dueDate ? new Date(geminiTask.dueDate) : timeframe?.end,\n      isRecurring: geminiTask.isRecurring ?? undefined,\n      recurrencePattern: geminiTask.recurrencePattern ?? undefined,\n    }));\n  }\n\n  private async createTasksFromDrafts(\n    drafts: Array<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>,\n    planId: string\n  ): Promise<Task[]> {\n    const tasks: Task[] = [];\n    for (const draft of drafts) {\n      const task = await taskRepo.create({\n        ...draft,\n        parentTaskId: planId,\n      });\n      tasks.push(task);\n    }\n    return tasks;\n  }\n\n  private mergeValidation(validations: ValidationResult[]): ValidationResult {\n    if (!validations.length) {\n      return { ok: true, requiresConfirmation: false, issues: [], summary: ['Validation passed'] };\n    }\n    const issues = validations.flatMap(v => v.issues || []);\n    const ok = !issues.some(i => i.severity === 'error');\n    const requiresConfirmation = issues.length > 0;\n    const summary = validations.flatMap(v => v.summary || []);\n    return { ok, requiresConfirmation, issues, summary };\n  }\n\n  private async recordAgentOutput(\n    input: PlannerInput,\n    output: PlannerOutput\n  ): Promise<void> {\n    // Would store the agent output for reflection\n    const { agentOutputRepo } = await import('@automation/data');\n    await agentOutputRepo.create({\n      agentType: 'planner',\n      input: input,\n      output: output,\n      confidence: 0.8\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2829, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/scheduler-agent.ts"],"sourcesContent":["import { Task, Schedule, ScheduledTask } from '@automation/types';\nimport {\n  BaseAgent,\n  BaseAgentOutput,\n  SchedulerInput,\n  SchedulerOutput,\n} from './base-agent';\nimport { TimeBlock } from '@automation/types';\nimport { scheduleRepo, agentOutputRepo } from '@automation/data';\nimport { GeminiService, validationService } from '@automation/services';\n\nexport class SchedulerAgent implements BaseAgent<SchedulerInput, SchedulerOutput> {\n  type = 'scheduler';\n\n  async process(input: SchedulerInput): Promise<BaseAgentOutput> {\n    const { user, tasks, date, existingEvents, constraints } = input;\n    const reasoning: string[] = [];\n\n    try {\n      // Try using Gemini for scheduling first\n      const geminiService = new GeminiService();\n      const prompt = geminiService.generatePrompt('scheduler', { \n        date,\n        energyProfile: user.preferences.energyProfile,\n        existingEvents: existingEvents || [],\n        constraints\n      });\n      \n      try {\n        const geminiResponse = await geminiService.generateContent(prompt);\n        const { schedule: geminiSchedule } = JSON.parse(geminiResponse);\n        \n        // Convert Gemini response to our schedule\n        const scheduledTasks = await this.createScheduledTasksFromGeminiResponse(\n          geminiSchedule.tasks,\n          tasks\n        );\n\n        // Pre-execution validation before persisting anything\n        const validation = validationService.validateSchedule({\n          tasks,\n          scheduled: scheduledTasks,\n          events: existingEvents || [],\n          user,\n          date,\n        });\n\n        // Philosophy 2.1 & 5: Always summarize and require confirmation if issues or not explicitly confirmed\n        const requiresConfirmation = validation.requiresConfirmation || !input.context?.confirmed;\n\n        if (!validation.ok || (requiresConfirmation && !input.context?.confirmed)) {\n          reasoning.push(validation.ok ? 'Schedule requires user review' : 'Validation blocked schedule creation');\n          return {\n            result: { \n              schedule: null, \n              reasoning, \n              validation, \n              requiresConfirmation: true,\n              draftScheduledTasks: scheduledTasks,\n              summary: `Proposed schedule for ${date.toLocaleDateString()} with ${scheduledTasks.length} tasks. ${validation.issues.length} points for review.`\n            } as any,\n            confidence: validation.ok ? 0.6 : 0.25,\n            metadata: { validation, scheduleId: null, taskCount: scheduledTasks.length }\n          };\n        }\n        \n        const schedule = await scheduleRepo.create({\n          date,\n          tasks: scheduledTasks,\n          notes: `AI scheduled on ${new Date().toLocaleDateString()}`,\n          energyProfile: user.preferences.energyProfile,\n          constraints: {\n            maxTasks: constraints?.maxDeepWorkSessions || 3,\n            maxDeepWorkSessions: constraints?.maxDeepWorkSessions || 2\n          },\n          validation,\n          userId: user.id,\n        });\n\n        reasoning.push(`AI scheduled ${scheduledTasks.length} tasks for ${date.toLocaleDateString()}`);\n        reasoning.push(`Total estimated work time: ${this.calculateTotalTime(scheduledTasks)} minutes`);\n        if (validation.requiresConfirmation) {\n          reasoning.push('User confirmation recommended before committing schedule');\n        }\n        \n        // Record agent output for reflection\n        await this.recordAgentOutput(input, { schedule, reasoning });\n\n        return {\n          result: { schedule, reasoning, validation } as SchedulerOutput,\n          confidence: 0.9, // Higher confidence with AI assistance\n          metadata: { scheduleId: schedule.id, taskCount: scheduledTasks.length, validation }\n        };\n      } catch (geminiError) {\n        console.warn('Gemini scheduling failed, using fallback:', geminiError);\n        \n        // Fallback to rule-based scheduling\n        const scheduledTasks = await this.scheduleTasks(\n          tasks,\n          date,\n          existingEvents || [],\n          constraints\n        );\n\n        const validation = validationService.validateSchedule({\n          tasks,\n          scheduled: scheduledTasks,\n          events: existingEvents || [],\n          user,\n          date,\n        });\n\n        if (!validation.ok) {\n          reasoning.push('Validation blocked schedule creation');\n          return {\n            result: { schedule: null, reasoning, validation } as SchedulerOutput,\n            confidence: 0.25,\n            metadata: { validation, scheduleId: null, taskCount: scheduledTasks.length }\n          };\n        }\n        \n        const schedule = await scheduleRepo.create({\n          date,\n          tasks: scheduledTasks,\n          notes: `Fallback scheduled on ${new Date().toLocaleDateString()}`,\n          energyProfile: user.preferences.energyProfile,\n          constraints: {\n            maxTasks: constraints?.maxDeepWorkSessions || 3,\n            maxDeepWorkSessions: constraints?.maxDeepWorkSessions || 2\n          },\n          validation,\n          userId: user.id,\n        });\n\n        reasoning.push(`Fallback scheduled ${scheduledTasks.length} tasks for ${date.toLocaleDateString()}`);\n        reasoning.push(`Total estimated work time: ${this.calculateTotalTime(scheduledTasks)} minutes`);\n        if (validation.requiresConfirmation) {\n          reasoning.push('User confirmation recommended before committing schedule');\n        }\n\n        return {\n          result: { schedule, reasoning } as SchedulerOutput,\n          confidence: 0.6, // Lower confidence with fallback\n          metadata: { scheduleId: schedule.id, taskCount: scheduledTasks.length, validation }\n        };\n      }\n    } catch (error) {\n      console.error('Error in Scheduler agent:', error);\n      return {\n        result: null,\n        confidence: 0,\n        metadata: { error: error instanceof Error ? error.message : String(error) }\n      };\n    }\n  }\n\n  private async scheduleTasks(\n    tasks: Task[],\n    date: Date,\n    existingEvents: TimeBlock[],\n    constraints?: any\n  ): Promise<ScheduledTask[]> {\n    const scheduledTasks: ScheduledTask[] = [];\n    \n    // Sort tasks by priority\n    const sortedTasks = tasks.sort((a, b) => {\n      const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 };\n      return priorityOrder[a.priority] - priorityOrder[b.priority];\n    });\n\n    let currentTime = this.getWorkStartTime(date);\n    const workEndTime = this.getWorkEndTime(date);\n    let deepWorkSessions = 0;\n    const maxDeepWorkSessions = constraints?.maxDeepWorkSessions || 2;\n\n    for (const task of sortedTasks) {\n      // Check if we can fit this task\n      const taskEndTime = new Date(currentTime.getTime() + task.estimatedTime * 60000);\n      \n      if (taskEndTime > workEndTime) {\n        // Can't fit this task today\n        continue;\n      }\n\n      // Check for deep work limit\n      if (task.focusLevel === 'deep' && deepWorkSessions >= maxDeepWorkSessions) {\n        continue;\n      }\n\n      // Check for conflicts with existing events\n      if (this.hasConflict(currentTime, taskEndTime, existingEvents)) {\n        // Find next available slot\n        const nextSlot = this.findNextAvailableSlot(taskEndTime, workEndTime, existingEvents);\n        if (!nextSlot) continue;\n        currentTime = nextSlot;\n      }\n\n      if (task.focusLevel === 'deep') {\n        deepWorkSessions++;\n      }\n\n      scheduledTasks.push({\n        taskId: task.id,\n        scheduledStart: new Date(currentTime),\n        scheduledEnd: taskEndTime,\n        status: 'scheduled'\n      });\n\n      // Add break time after task\n      const breakTime = task.focusLevel === 'deep' ? 15 : 5;\n      currentTime = new Date(taskEndTime.getTime() + breakTime * 60000);\n    }\n\n    return scheduledTasks;\n  }\n\n  private getWorkStartTime(date: Date): Date {\n    const start = new Date(date);\n    start.setHours(9, 0, 0, 0);\n    return start;\n  }\n\n  private getWorkEndTime(date: Date): Date {\n    const end = new Date(date);\n    end.setHours(17, 0, 0, 0);\n    return end;\n  }\n\n  private hasConflict(start: Date, end: Date, events: TimeBlock[]): boolean {\n    return events.some(event => \n      (start < new Date(event.end) && end > new Date(event.start))\n    );\n  }\n\n  private findNextAvailableSlot(\n    currentTime: Date,\n    workEndTime: Date,\n    events: TimeBlock[]\n  ): Date | null {\n    let slotStart = currentTime;\n    \n    while (slotStart < workEndTime) {\n      const conflict = events.find(event =>\n        slotStart < new Date(event.end) && slotStart > new Date(event.start)\n      );\n      \n      if (!conflict) return slotStart;\n      slotStart = new Date(conflict.end);\n    }\n    \n    return null;\n  }\n\n  private calculateTotalTime(scheduledTasks: ScheduledTask[]): number {\n    return scheduledTasks.reduce((total, task) => {\n      const duration = task.scheduledEnd.getTime() - task.scheduledStart.getTime();\n      return total + Math.ceil(duration / 60000);\n    }, 0);\n  }\n\n  private async createScheduledTasksFromGeminiResponse(geminiTasks: any[], originalTasks: Task[]): Promise<ScheduledTask[]> {\n    const scheduledTasks: ScheduledTask[] = [];\n    \n    // Create a map for quick lookup\n    const taskMap = new Map<string, Task>();\n    for (const task of originalTasks) {\n      taskMap.set(task.id, task);\n    }\n    \n    // Convert Gemini response to our scheduled tasks\n    for (const geminiTask of geminiTasks) {\n      const scheduledTask: ScheduledTask = {\n        taskId: geminiTask.taskId,\n        scheduledStart: new Date(geminiTask.scheduledStart),\n        scheduledEnd: new Date(geminiTask.scheduledEnd),\n        status: 'scheduled'\n      };\n      \n      scheduledTasks.push(scheduledTask);\n    }\n\n    return scheduledTasks;\n  }\n\n  private async recordAgentOutput(\n    input: SchedulerInput,\n    output: SchedulerOutput\n  ): Promise<void> {\n    await agentOutputRepo.create({\n      agentType: 'scheduler',\n      input: input,\n      output: output,\n      confidence: 0.85\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3099, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/prioritization-agent.ts"],"sourcesContent":["import { Task } from '@automation/types';\nimport {\n  BaseAgent,\n  BaseAgentOutput,\n  PrioritizationInput,\n  PrioritizationOutput,\n  PriorityFactors,\n  PrioritizedTask\n} from './base-agent';\nimport { taskRepo, agentOutputRepo } from '@automation/data';\nimport { GeminiService, validationService } from '@automation/services';\n\nexport class PrioritizationAgent implements BaseAgent<PrioritizationInput, PrioritizationOutput> {\n  type = 'prioritization';\n\n  async process(input: PrioritizationInput): Promise<BaseAgentOutput> {\n    const { user, tasks, currentContext } = input;\n    const reasoning: string[] = [];\n\n    try {\n      // Use Gemini to prioritize tasks\n      const geminiService = new GeminiService();\n      const prompt = geminiService.generatePrompt('prioritization', { \n        tasks,\n        currentContext\n      });\n      \n      const geminiResponse = await geminiService.generateContent(prompt);\n      let parsedResponse;\n      try {\n        parsedResponse = JSON.parse(geminiResponse);\n      } catch (e) {\n        // Handle markdown code blocks if present\n        const { parseJsonFromGemini } = await import('@automation/utils');\n        parsedResponse = parseJsonFromGemini(geminiResponse) as any;\n      }\n      \n      const { tasks: geminiTasks, reasoning: geminiReasoning } = parsedResponse;\n      \n      // Convert Gemini response to our prioritized tasks\n      const prioritizedTasks = await this.createPrioritizedTasksFromGeminiResponse(geminiTasks, tasks);\n      const validation = this.validatePriorities(prioritizedTasks);\n      \n      // Philosophy 5: Pre-Execution Validation Layer\n      const requiresConfirmation = validation.requiresConfirmation || !input.context?.confirmed;\n\n      if (validation.issues.some(i => i.severity === 'error')) {\n        return {\n          result: { tasks: [], reasoning: [validation.summary[0]], validation, requiresConfirmation: true } as any,\n          confidence: 0.3,\n          metadata: { validation, taskCount: tasks.length }\n        };\n      }\n      \n      // Sort tasks by priority score\n      const sortedTasks = prioritizedTasks.sort((a, b) => b.priorityScore - a.priorityScore);\n      \n      if (geminiReasoning) reasoning.push(...(Array.isArray(geminiReasoning) ? geminiReasoning : [geminiReasoning]));\n      reasoning.push(`Prioritized ${tasks.length} tasks using AI analysis`);\n      reasoning.push(`Highest priority: ${sortedTasks[0]?.title || 'None'}`);\n      reasoning.push(`Context consideration: ${currentContext ? 'Applied' : 'Not available'}`);\n\n      // Record agent output for reflection\n      await this.recordAgentOutput(input, { tasks: sortedTasks, reasoning });\n\n      // Ensure confirmation is required if issues exist, even if not explicitly confirmed\n      const finalRequiresConfirmation = requiresConfirmation || validation.requiresConfirmation;\n\n      return {\n        result: { \n          tasks: sortedTasks, \n          reasoning, \n          validation,\n          requiresConfirmation: finalRequiresConfirmation,\n          summary: `Prioritized ${tasks.length} tasks. Top task: \"${sortedTasks[0]?.title}\".`\n        } as any,\n        confidence: 0.9,\n        metadata: { taskCount: tasks.length, contextConsidered: !!currentContext, validation }\n      };\n    } catch (error) {\n      console.error('Error in Prioritization agent:', error);\n      \n      // Fallback to rule-based prioritization\n      const prioritizedTasks = await this.calculatePriorityScores(tasks, currentContext);\n      const validation = this.validatePriorities(prioritizedTasks);\n      if (!validation.ok) {\n        return {\n          result: { tasks: [], reasoning, validation } as PrioritizationOutput,\n          confidence: 0.25,\n          metadata: { validation, taskCount: tasks.length, contextConsidered: !!currentContext }\n        };\n      }\n      const sortedTasks = prioritizedTasks.sort((a, b) => b.priorityScore - a.priorityScore);\n      \n      reasoning.push(`Used rule-based prioritization as fallback`);\n      \n      return {\n        result: { tasks: sortedTasks, reasoning } as PrioritizationOutput,\n        confidence: 0.6, // Lower confidence with fallback\n        metadata: { taskCount: tasks.length, contextConsidered: !!currentContext, validation }\n      };\n    }\n  }\n\n  private async calculatePriorityScores(\n    tasks: Task[], \n    currentContext?: PrioritizationInput['currentContext']\n  ): Promise<PrioritizedTask[]> {\n    const prioritizedTasks: PrioritizedTask[] = [];\n\n    for (const task of tasks) {\n      const factors = await this.calculatePriorityFactors(task, currentContext);\n      const priorityScore = this.combinePriorityFactors(factors);\n      \n      prioritizedTasks.push({\n        ...task,\n        priority: this.mapScoreToPriority(priorityScore),\n        priorityScore,\n        factors\n      });\n    }\n\n    return prioritizedTasks;\n  }\n\n  private async calculatePriorityFactors(\n    task: Task, \n    currentContext?: PrioritizationInput['currentContext']\n  ): Promise<PriorityFactors> {\n    const factors: PriorityFactors = {\n      deadlineImportance: this.calculateDeadlineImportance(task),\n      longTermValue: this.calculateLongTermValue(task),\n      requiredFocus: this.mapFocusLevel(task.focusLevel),\n      energyCost: this.mapEnergyRequirement(task.energyRequirement),\n      dependencyComplexity: this.calculateDependencyComplexity(task),\n      userPreference: 0.5 // Default, would be personalized with data\n    };\n\n    // Adjust factors based on current context\n    if (currentContext) {\n      // If user has low energy, lower priority for high-energy tasks\n      if (currentContext.currentEnergy === 'low' && factors.energyCost > 0.6) {\n        factors.userPreference -= 0.3;\n      }\n      \n      // If limited time, prioritize shorter tasks\n      if (currentContext.availableTime < task.estimatedTime * 1.5) {\n        factors.deadlineImportance -= 0.2;\n      }\n      \n      // If location-specific tasks match current location, boost priority\n      if (task.context !== 'anywhere' && task.context === currentContext.location) {\n        factors.userPreference += 0.2;\n      }\n    }\n\n    return factors;\n  }\n\n  private calculateDeadlineImportance(task: Task): number {\n    if (!task.dueDate) return 0.3; // No deadline = moderate importance\n    \n    const now = new Date();\n    const dueDate = new Date(task.dueDate);\n    const daysUntilDue = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n    \n    if (daysUntilDue <= 0) return 1; // Overdue\n    if (daysUntilDue <= 1) return 0.9; // Due today or tomorrow\n    if (daysUntilDue <= 3) return 0.7; // Due this week\n    if (daysUntilDue <= 7) return 0.5; // Due next week\n    return 0.3; // More than a week away\n  }\n\n  private calculateLongTermValue(task: Task): number {\n    // Simple heuristic based on priority and tags\n    let value = 0.5;\n    \n    if (task.priority === 'urgent' || task.priority === 'high') value += 0.3;\n    if (task.tags.includes('important') || task.tags.includes('strategic')) value += 0.3;\n    if (task.tags.includes('maintenance') || task.tags.includes('admin')) value -= 0.2;\n    \n    return Math.min(1, Math.max(0, value));\n  }\n\n  private mapFocusLevel(focusLevel: Task['focusLevel']): number {\n    switch (focusLevel) {\n      case 'shallow': return 0.3;\n      case 'medium': return 0.5;\n      case 'deep': return 0.8;\n      default: return 0.5;\n    }\n  }\n\n  private mapEnergyRequirement(energy: Task['energyRequirement']): number {\n    switch (energy) {\n      case 'low': return 0.2;\n      case 'medium': return 0.5;\n      case 'high': return 0.8;\n      default: return 0.5;\n    }\n  }\n\n  private calculateDependencyComplexity(task: Task): number {\n    const dependencyCount = task.dependencies.length + task.subtasks.length;\n    \n    if (dependencyCount === 0) return 0.1;\n    if (dependencyCount === 1) return 0.3;\n    if (dependencyCount <= 3) return 0.5;\n    if (dependencyCount <= 5) return 0.7;\n    return 0.9;\n  }\n\n  private combinePriorityFactors(factors: PriorityFactors): number {\n    // Weighted combination of factors\n    const weightedFactors = [\n      { factor: factors.deadlineImportance, weight: 0.25 },\n      { factor: factors.longTermValue, weight: 0.20 },\n      { factor: factors.requiredFocus, weight: 0.15 },\n      { factor: 1 - factors.energyCost, weight: 0.15 }, // Inverted because high cost is bad\n      { factor: 1 - factors.dependencyComplexity, weight: 0.10 }, // Inverted because complex is bad\n      { factor: factors.userPreference, weight: 0.15 }\n    ];\n\n    return weightedFactors.reduce((sum, { factor, weight }) => sum + factor * weight, 0);\n  }\n\n  private mapScoreToPriority(score: number): 'low' | 'medium' | 'high' | 'urgent' {\n    if (score >= 0.8) return 'urgent';\n    if (score >= 0.6) return 'high';\n    if (score >= 0.4) return 'medium';\n    return 'low';\n  }\n\n  private validatePriorities(tasks: PrioritizedTask[]) {\n    // Warn if tasks lack due dates or if urgent tasks exceed 6 per day\n    const issues: any[] = [];\n    const urgentCount = tasks.filter(t => t.priority === 'urgent').length;\n    if (urgentCount > 6) {\n      issues.push({\n        code: 'too_many_urgent',\n        severity: 'warn',\n        message: `There are ${urgentCount} urgent tasks; this may be unrealistic.`,\n      });\n    }\n    tasks.forEach(t => {\n      if (!t.dueDate) {\n        issues.push({\n          code: 'missing_due_date',\n          severity: 'warn',\n          message: `Task \"${t.title}\" has no due date; prioritize with caution.`,\n          relatedIds: [t.id],\n        });\n      }\n    });\n\n    const ok = !issues.some(i => i.severity === 'error');\n    const summary = issues.length\n      ? [`${issues.filter(i => i.severity === 'warn').length} warning(s) detected`]\n      : ['Validation passed'];\n    return {\n      ok,\n      requiresConfirmation: issues.length > 0,\n      issues,\n      summary,\n    };\n  }\n\n  private async createPrioritizedTasksFromGeminiResponse(geminiTasks: any[], originalTasks: Task[]): Promise<PrioritizedTask[]> {\n    const prioritizedTasks: PrioritizedTask[] = [];\n    \n    // Create a map for quick lookup\n    const taskMap = new Map<string, Task>();\n    for (const task of originalTasks) {\n      taskMap.set(task.id, task);\n    }\n    \n    // Convert Gemini response to our prioritized tasks\n    for (const geminiTask of geminiTasks) {\n      const originalTask = taskMap.get(geminiTask.id);\n      if (!originalTask) continue;\n      \n      // Create priority factors for this task\n      const factors: PriorityFactors = await this.calculatePriorityFactors(originalTask);\n      \n      prioritizedTasks.push({\n        ...originalTask,\n        priority: geminiTask.priority,\n        priorityScore: geminiTask.priorityScore,\n        factors\n      });\n    }\n    \n    // If any tasks weren't included in Gemini response, add them with default priority\n    for (const task of originalTasks) {\n      if (!prioritizedTasks.some(pt => pt.id === task.id)) {\n        const factors: PriorityFactors = await this.calculatePriorityFactors(task);\n        \n        prioritizedTasks.push({\n          ...task,\n          priority: 'medium',\n          priorityScore: 0.5,\n          factors\n        });\n      }\n    }\n\n    return prioritizedTasks;\n  }\n\n  private async recordAgentOutput(\n    input: PrioritizationInput,\n    output: PrioritizationOutput\n  ): Promise<void> {\n    await agentOutputRepo.create({\n      agentType: 'prioritizer',\n      input: input,\n      output: output,\n      confidence: 0.9\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3429, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/execution-agent.ts"],"sourcesContent":["import { Task } from '@automation/types';\nimport {\n  BaseAgent,\n  BaseAgentOutput,\n  ExecutionInput,\n  ExecutionOutput\n} from './base-agent';\nimport { taskRepo, agentOutputRepo } from '@automation/data';\nimport { GeminiService, validationService } from '@automation/services';\n\nexport class ExecutionAgent implements BaseAgent<ExecutionInput, ExecutionOutput> {\n  type = 'execution';\n\n  async process(input: ExecutionInput): Promise<BaseAgentOutput> {\n    const { user, currentTask, progress, nextSteps } = input;\n    const reasoning: string[] = [];\n\n    try {\n      // Pre-flight: ensure task has time context\n      const validation = validationService.validateTaskInput({ task: currentTask, existing: await taskRepo.getAll() });\n      if (!validation.ok) {\n        return {\n          result: {\n            nextStep: null,\n            context: { relatedTasks: [], blockers: [], resources: [] },\n            suggestions: validation.summary ?? []\n          } as ExecutionOutput,\n          confidence: 0.2,\n          metadata: { validation }\n        };\n      }\n\n      // Try using Gemini for guidance first\n      const geminiService = new GeminiService();\n      const prompt = geminiService.generatePrompt('execution', {\n        currentTask,\n        progress,\n        nextSteps\n      });\n      \n      try {\n        const geminiResponse = await geminiService.generateContent(prompt);\n        let executionOutput;\n        try {\n          executionOutput = JSON.parse(geminiResponse);\n        } catch (e) {\n          const { parseJsonFromGemini } = await import('@automation/utils');\n          executionOutput = parseJsonFromGemini(geminiResponse) as any;\n        }\n        \n        // Philosophy 2.1: Explain consequences and identifying blockers\n        reasoning.push(`AI analyzed task: ${currentTask.title}`);\n        reasoning.push(`Identified ${executionOutput.context?.blockers?.length || 0} potential blockers`);\n        reasoning.push(`Next step: ${executionOutput.nextStep?.action || 'Review task'} (${executionOutput.nextStep?.estimatedTime || 0} minutes)`);\n        \n        // Record agent output for reflection\n        await this.recordAgentOutput(input, {\n          nextStep: executionOutput.nextStep,\n          context: executionOutput.context,\n          suggestions: executionOutput.suggestions\n        });\n\n        return {\n          result: {\n            nextStep: executionOutput.nextStep,\n            context: executionOutput.context,\n            suggestions: executionOutput.suggestions,\n            summary: `Translating intent for \"${currentTask.title}\": Next action is ${executionOutput.nextStep?.action}.`\n          } as any,\n          confidence: 0.85, \n          metadata: {\n            taskId: currentTask.id,\n            blockersFound: executionOutput.context?.blockers?.length || 0,\n            relatedTasksFound: executionOutput.context?.relatedTasks?.length || 0\n          }\n        };\n      } catch (geminiError) {\n        console.warn('Gemini execution guidance failed, using fallback:', geminiError);\n        \n        // Fallback to rule-based guidance\n        // Find related tasks that might provide context\n        const relatedTasks = await this.findRelatedTasks(currentTask);\n        \n        // Identify blockers\n        const blockers = await this.identifyBlockers(currentTask);\n        \n        // Determine the next step\n        const nextStep = this.determineNextStep(currentTask, progress, nextSteps);\n        \n        // Get resources that might be helpful\n        const resources = this.identifyResources(currentTask, blockers);\n\n        reasoning.push(`Analyzed task: ${currentTask.title}`);\n        reasoning.push(`Used fallback guidance`);\n        \n        // Record agent output for reflection\n        await this.recordAgentOutput(input, {\n          nextStep,\n          context: { relatedTasks, blockers, resources },\n          suggestions: this.generateSuggestions(currentTask, blockers)\n        });\n\n        return {\n          result: {\n            nextStep,\n            context: { relatedTasks, blockers, resources },\n            suggestions: this.generateSuggestions(currentTask, blockers)\n          } as ExecutionOutput,\n          confidence: nextStep ? 0.6 : 0.3, // Lower confidence with fallback\n          metadata: {\n            taskId: currentTask.id,\n            blockersFound: blockers.length,\n            relatedTasksFound: relatedTasks.length\n          }\n        };\n      }\n    } catch (error) {\n      console.error('Error in Execution agent:', error);\n      return {\n        result: null,\n        confidence: 0,\n        metadata: { error: error instanceof Error ? error.message : String(error) }\n      };\n    }\n  }\n\n  private async findRelatedTasks(currentTask: Task): Promise<Task[]> {\n    // Find tasks with similar tags, same parent/child relationships, or dependencies\n    const allTasks = await taskRepo.getAll();\n    \n    return allTasks.filter(task => {\n      // Skip the current task itself\n      if (task.id === currentTask.id) return false;\n      \n      // Check for shared tags\n      const hasSharedTags = task.tags.some(tag => currentTask.tags.includes(tag));\n      \n      // Check for dependencies\n      const hasDependency = \n        task.dependencies.includes(currentTask.id) ||\n        currentTask.dependencies.includes(task.id);\n      \n      // Check for parent/child relationships\n      const hasRelationship = \n        task.parentTaskId === currentTask.id ||\n        currentTask.parentTaskId === task.id;\n      \n      return hasSharedTags || hasDependency || hasRelationship;\n    });\n  }\n\n  private async identifyBlockers(currentTask: Task): Promise<string[]> {\n    const blockers: string[] = [];\n    \n    // Check if task depends on incomplete tasks\n    if (currentTask.dependencies.length > 0) {\n      for (const depId of currentTask.dependencies) {\n        const depTask = await taskRepo.getById(depId);\n        if (depTask && depTask.status !== 'completed') {\n          blockers.push(`Dependency task not completed: ${depTask.title}`);\n        }\n      }\n    }\n    \n    // Check if task is blocked by context (e.g., requires being at work)\n    if (currentTask.context === 'work') {\n      blockers.push('This task requires being at work');\n    }\n    \n    // Check if task requires resources that might not be available\n    if (currentTask.tags.includes('collaboration')) {\n      blockers.push('This task requires collaboration - make sure team members are available');\n    }\n    \n    if (currentTask.focusLevel === 'deep' && currentTask.estimatedTime > 120) {\n      blockers.push('This task requires a long deep work session - ensure you have focused time');\n    }\n    \n    return blockers;\n  }\n\n  private determineNextStep(\n    task: Task, \n    progress?: ExecutionInput['progress'], \n    nextSteps?: string[]\n  ): ExecutionOutput['nextStep'] {\n    // If task hasn't started, first step is to begin\n    if (task.status === 'pending') {\n      return {\n        action: 'Start working on this task',\n        instructions: `Begin with ${this.getFirstStep(task)}`,\n        estimatedTime: Math.min(15, task.estimatedTime)\n      };\n    }\n    \n    // If task is in progress and we have predefined steps\n    if (task.status === 'in-progress' && nextSteps && nextSteps.length > 0) {\n      const completedSteps = progress?.completedSteps || [];\n      const remainingSteps = nextSteps.filter(step => !completedSteps.includes(step));\n      \n      if (remainingSteps.length > 0) {\n        const nextStep = remainingSteps[0];\n        return {\n          action: `Continue with: ${nextStep}`,\n          instructions: `Focus on completing ${nextStep}`,\n          estimatedTime: Math.min(30, task.estimatedTime / remainingSteps.length)\n        };\n      }\n    }\n    \n    // If all steps completed or no steps defined, suggest completing the task\n    return {\n      action: 'Finish and mark task as complete',\n      instructions: 'Review your work and mark the task as complete',\n      estimatedTime: 5\n    };\n  }\n\n  private getFirstStep(task: Task): string {\n    // Simple heuristic for first step based on task type\n    if (task.tags.includes('research')) {\n      return 'research and information gathering';\n    }\n    \n    if (task.tags.includes('implementation')) {\n      return 'setting up your development environment';\n    }\n    \n    if (task.tags.includes('writing')) {\n      return 'outlining your main points';\n    }\n    \n    return 'setting up your workspace';\n  }\n\n  private identifyResources(task: Task, blockers: string[]): string[] {\n    const resources: string[] = [];\n    \n    // Add context-specific resources\n    if (task.tags.includes('research')) {\n      resources.push('Note-taking tool', 'Reference materials', 'Bookmark tool');\n    }\n    \n    if (task.tags.includes('implementation') || task.tags.includes('coding')) {\n      resources.push('Code editor', 'Documentation', 'Version control');\n    }\n    \n    if (task.tags.includes('collaboration')) {\n      resources.push('Communication tool', 'Shared workspace', 'Meeting scheduler');\n    }\n    \n    if (task.focusLevel === 'deep') {\n      resources.push('Focus app/website blocker', 'Noise-cancelling headphones');\n    }\n    \n    // Add resources for blockers\n    blockers.forEach(blocker => {\n      if (blocker.includes('collaboration')) {\n        resources.push('Team contact list');\n      }\n      \n      if (blocker.includes('deep_work')) {\n        resources.push('Time blocking tool');\n      }\n    });\n    \n    return [...new Set(resources)]; // Remove duplicates\n  }\n\n  private generateSuggestions(task: Task, blockers: string[]): string[] {\n    const suggestions: string[] = [];\n    \n    if (task.status === 'pending') {\n      suggestions.push('Start with a small, concrete step to build momentum');\n    }\n    \n    if (blockers.length > 0) {\n      suggestions.push('Address any blockers before continuing');\n      suggestions.push('Consider if the task can be simplified to avoid blockers');\n    }\n    \n    if (task.estimatedTime > 120) {\n      suggestions.push('Consider breaking this into smaller subtasks');\n      suggestions.push('schedule multiple sessions for this task');\n    }\n    \n    if (task.focusLevel === 'deep') {\n      suggestions.push('Make sure you have adequate time and low interruption for this task');\n      suggestions.push('Consider scheduling during your peak energy hours');\n    }\n    \n    return suggestions;\n  }\n\n  private async recordAgentOutput(\n    input: ExecutionInput,\n    output: ExecutionOutput\n  ): Promise<void> {\n    await agentOutputRepo.create({\n      agentType: 'execution',\n      input: input,\n      output: output,\n      confidence: 0.75\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3701, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/reflection-agent.ts"],"sourcesContent":["import { Task } from '@automation/types';\nimport {\n  BaseAgent,\n  BaseAgentOutput,\n  ReflectionInput,\n  ReflectionOutput\n} from './base-agent';\nimport { agentOutputRepo, userRepo } from '@automation/data';\nimport { GeminiService } from '@automation/services';\n\nexport class ReflectionAgent implements BaseAgent<ReflectionInput, ReflectionOutput> {\n  type = 'reflection';\n\n  async process(input: ReflectionInput): Promise<BaseAgentOutput> {\n    const { user, tasks, completionHistory, userFeedback } = input;\n    const reasoning: string[] = [];\n\n    try {\n      // Try using Gemini for reflection first\n      const geminiService = new GeminiService();\n      const prompt = geminiService.generatePrompt('reflection', {\n        tasks,\n        completionHistory,\n        userFeedback\n      });\n      \n      try {\n        const geminiResponse = await geminiService.generateContent(prompt);\n        let reflectionOutput;\n        try {\n          reflectionOutput = JSON.parse(geminiResponse);\n        } catch (e) {\n          const { parseJsonFromGemini } = await import('@automation/utils');\n          reflectionOutput = parseJsonFromGemini(geminiResponse) as any;\n        }\n        \n        reasoning.push(`AI analyzed ${completionHistory.length} task completions`);\n        reasoning.push(`Identified ${reflectionOutput.insights?.patterns?.length || 0} behavioral patterns`);\n        \n        // Record agent output for future analysis\n        await this.recordAgentOutput(input, reflectionOutput);\n\n        return {\n          result: {\n            insights: reflectionOutput.insights,\n            recommendations: reflectionOutput.recommendations,\n            summary: `Reflection complete: Identified ${reflectionOutput.insights?.patterns?.length || 0} patterns and ${reflectionOutput.recommendations?.length || 0} advisory recommendations.`\n          } as any,\n          confidence: 0.9,\n          metadata: {\n            patternsFound: reflectionOutput.insights?.patterns?.length || 0,\n            adjustmentsIdentified: reflectionOutput.insights?.adjustments?.length || 0\n          }\n        };\n      } catch (geminiError) {\n        console.warn('Gemini reflection analysis failed, using fallback:', geminiError);\n        \n        // Fallback to rule-based analysis\n        // Analyze completion patterns\n        const patterns = this.analyzePatterns(completionHistory);\n        \n        // Generate insights and recommendations\n        const insights = {\n          patterns,\n          adjustments: await this.identifyAdjustments(patterns, userFeedback, tasks)\n        };\n        \n        const recommendations = this.generateRecommendations(patterns, insights.adjustments);\n        \n        reasoning.push(`Fallback analyzed ${completionHistory.length} task completions`);\n        reasoning.push(`Identified ${patterns.length} behavioral patterns`);\n        \n        // Record agent output for future analysis\n        await this.recordAgentOutput(input, { insights, recommendations });\n\n        return {\n          result: { insights, recommendations } as ReflectionOutput,\n          confidence: 0.6, // Lower confidence with fallback\n          metadata: {\n            patternsFound: patterns.length,\n            adjustmentsIdentified: insights.adjustments.length\n          }\n        };\n      }\n    } catch (error) {\n      console.error('Error in Reflection agent:', error);\n      return {\n        result: null,\n        confidence: 0,\n        metadata: { error: error instanceof Error ? error.message : String(error) }\n      };\n    }\n  }\n\n  private analyzePatterns(completionHistory: ReflectionInput['completionHistory']): string[] {\n    const patterns: string[] = [];\n    \n    // Check for time estimation patterns\n    const timeAccuracy = completionHistory.map(h => h.actualTime / h.plannedTime);\n    const avgTimeAccuracy = timeAccuracy.reduce((sum, accuracy) => sum + accuracy, 0) / timeAccuracy.length;\n    \n    if (avgTimeAccuracy > 1.5) {\n      patterns.push('Consistently underestimates task duration');\n    } else if (avgTimeAccuracy < 0.8) {\n      patterns.push('Consistently overestimates task duration');\n    } else {\n      patterns.push('Generally accurate time estimation');\n    }\n    \n    // Check for energy patterns\n    const highEnergyTasks = completionHistory.filter(h => {\n      // In a real implementation, would look up task quality\n      return h.quality === 'excellent'; // High quality work tends to happen during peak energy\n    });\n    \n    if (highEnergyTasks.length / completionHistory.length > 0.7) {\n      patterns.push('Performs well on high-energy tasks');\n    }\n    \n    // Check for task type patterns\n    const tagGroups = this.groupByTags(completionHistory);\n    for (const [tag, completions] of Object.entries(tagGroups)) {\n      if (completions.length < 2) continue;\n      \n      const avgQuality = completions.reduce((sum, c) => sum + (c.quality === 'excellent' ? 2 : c.quality === 'good' ? 1 : 0), 0) / completions.length;\n      const avgAccuracy = completions.reduce((sum, c) => sum + c.actualTime / c.plannedTime, 0) / completions.length;\n      \n      if (avgQuality > 1.5) {\n        patterns.push(`Strong performer on ${tag} tasks`);\n      }\n      \n      if (avgAccuracy > 1.3) {\n        patterns.push(`Underestimates ${tag} task duration`);\n      }\n    }\n    \n    // Check for procrastination patterns\n    const delayedTasks = completionHistory.filter(h => {\n      // Would check if task was completed after due date\n      return false; // Placeholder logic\n    });\n    \n    if (delayedTasks.length / completionHistory.length > 0.3) {\n      patterns.push('Frequently delays task completion');\n    }\n    \n    return patterns;\n  }\n\n  private groupByTags(completionHistory: ReflectionInput['completionHistory']): Record<string, typeof completionHistory> {\n    const groups: Record<string, typeof completionHistory> = {};\n    \n    // This is a simplified version - would need to look up actual task details\n    // For now, we'll create some example groups\n    \n    const researchTasks = completionHistory.slice(0, Math.floor(completionHistory.length / 3));\n    const implementationTasks = completionHistory.slice(\n      Math.floor(completionHistory.length / 3),\n      Math.floor(completionHistory.length * 2 / 3)\n    );\n    const otherTasks = completionHistory.slice(Math.floor(completionHistory.length * 2 / 3));\n    \n    if (researchTasks.length > 0) groups['research'] = researchTasks;\n    if (implementationTasks.length > 0) groups['implementation'] = implementationTasks;\n    if (otherTasks.length > 0) groups['other'] = otherTasks;\n    \n    return groups;\n  }\n\n  private async identifyAdjustments(\n    patterns: string[], \n    userFeedback?: ReflectionInput['userFeedback'], \n    tasks?: Task[]\n  ): Promise<ReflectionOutput['insights']['adjustments']> {\n    const adjustments: ReflectionOutput['insights']['adjustments'] = [];\n    \n    // Time estimation adjustments\n    if (patterns.includes('Consistently underestimates task duration')) {\n      adjustments.push({\n        type: 'time',\n        before: 'Current time estimation approach',\n        after: 'Increase estimate by 50% and track actual vs planned time',\n        reason: 'Tasks consistently take longer than expected'\n      });\n    }\n    \n    if (patterns.includes('Consistently overestimates task duration')) {\n      adjustments.push({\n        type: 'time',\n        before: 'Current time estimation approach',\n        after: 'Reduce estimate by 25% and break into smaller milestones',\n        reason: 'Tasks consistently completed faster than expected'\n      });\n    }\n    \n    // Energy-related adjustments\n    if (patterns.includes('Performs well on high-energy tasks')) {\n      adjustments.push({\n        type: 'energy',\n        before: 'Mixed task scheduling',\n        after: 'Schedule high-focus work during peak energy hours and low-focus tasks elsewhere',\n        reason: 'Performance is better when matching task energy requirements to personal energy levels'\n      });\n    }\n    \n    // Priority adjustments\n    if (userFeedback && userFeedback.some(feedback => feedback.difficulty === 'too-hard')) {\n      adjustments.push({\n        type: 'priority',\n        before: 'Current task prioritization',\n        after: 'Break complex tasks earlier and give more time for preparation',\n        reason: 'Some tasks are perceived as too difficult without proper preparation'\n      });\n    }\n    \n    // Process adjustments\n    if (patterns.includes('Frequently delays task completion')) {\n      adjustments.push({\n        type: 'process',\n        before: 'Current planning process',\n        after: 'Add more frequent check-ins and break large tasks into smaller steps',\n        reason: 'Delaying completion suggests tasks seem overwhelming or not urgent enough'\n      });\n    }\n    \n    return adjustments;\n  }\n\n  private generateRecommendations(patterns: string[], adjustments: ReflectionOutput['insights']['adjustments']): string[] {\n    const recommendations: string[] = [];\n    \n    if (patterns.includes('Consistently underestimates task duration')) {\n      recommendations.push('Start tracking actual vs. planned time for all tasks to improve estimation');\n      recommendations.push('Add 20-50% buffer time to all task estimates');\n    }\n    \n    if (patterns.includes('Performs well on high-energy tasks')) {\n      recommendations.push('Schedule your most challenging work during your peak energy hours');\n      recommendations.push('Save low-energy tasks for when your energy is lower');\n    }\n    \n    if (patterns.includes('Frequently delays task completion')) {\n      recommendations.push('Break down complex tasks into smaller, more manageable chunks');\n      recommendations.push('Set up regular check-ins to stay on track');\n    }\n    \n    if (adjustments.some(adj => adj.type === 'priority')) {\n      recommendations.push('Re-evaluate your task prioritization method');\n      recommendations.push('Consider using the Eisenhower matrix (urgent/important) for better focus');\n    }\n    \n    // General recommendations\n    recommendations.push('Review your task completion patterns weekly');\n    recommendations.push('Adjust your planning approach based on actual completion data');\n    \n    return recommendations;\n  }\n\n  private async recordAgentOutput(\n    input: ReflectionInput,\n    output: ReflectionOutput\n  ): Promise<void> {\n    await agentOutputRepo.create({\n      agentType: 'reflection',\n      input: input,\n      output: output,\n      confidence: 0.85\n    });\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3929, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/router-agent.ts"],"sourcesContent":["import { BaseAgent, BaseAgentOutput, BaseAgentInput } from './base-agent';\nimport { GeminiService } from '@automation/services';\n\nexport type InputType = 'task' | 'plan' | 'note' | 'reminder' | 'question';\n\nexport interface RouterInput extends BaseAgentInput {\n  input: string;\n}\n\nexport interface RouterOutput {\n  type: InputType;\n  confidence: number;\n  reasoning: string;\n  suggestedAction?: string;\n}\n\nexport class RouterAgent implements BaseAgent<RouterInput, RouterOutput> {\n  type = 'router';\n  private geminiService: GeminiService;\n\n  constructor() {\n    this.geminiService = new GeminiService();\n  }\n\n  async process(input: RouterInput): Promise<BaseAgentOutput> {\n    const { input: userInput } = input;\n\n    try {\n      const classification = await this.classifyInput(userInput);\n      \n      return {\n        result: classification,\n        confidence: classification.confidence,\n        metadata: {\n          inputType: classification.type,\n          reasoning: classification.reasoning,\n        },\n      };\n    } catch (error) {\n      console.error('Error in Router agent:', error);\n      return {\n        result: {\n          type: 'question',\n          confidence: 0.5,\n          reasoning: 'Failed to classify input, defaulting to question',\n        } as RouterOutput,\n        confidence: 0.5,\n        metadata: { error: error instanceof Error ? error.message : String(error) },\n      };\n    }\n  }\n\n  private async classifyInput(input: string): Promise<RouterOutput> {\n    const prompt = `You are a intent classification AI for a productivity system. Your goal is to translate user input into the correct system operation.\n\nPhilosophy:\n- AI as a translator, not an authority.\n- Identify intent accurately to preserve trust.\n- Be conservative if ambiguous and classify as \"question\" to trigger clarification.\n\nAnalyze the following user input and classify it into one of these categories:\n1. \"task\" - A single actionable item (e.g., \"Buy groceries\", \"Call John\", \"Finish report\")\n2. \"plan\" - A multi-step goal or project (e.g., \"Build a website\", \"Plan a vacation\", \"Learn Spanish\")\n3. \"note\" - Information to remember (e.g., \"John's phone number is 555-1234\", \"Meeting moved to Friday\")\n4. \"reminder\" - A time-based alert (e.g., \"Remind me to call mom tomorrow\", \"Set reminder for dentist appointment\")\n5. \"question\" - A question or ambiguous command that needs clarification (e.g., \"What tasks do I have today?\", \"How do I prioritize?\")\n\nUser Input: \"${input}\"\n\nAnalyze the intent and content. Consider:\n- Single action vs multiple steps\n- Time references (reminders)\n- Question words (what, how, when, why)\n- Information storage vs action items\n\nReturn your response as JSON:\n{\n  \"type\": \"task\" | \"plan\" | \"note\" | \"reminder\" | \"question\",\n  \"confidence\": 0.0-1.0,\n  \"reasoning\": \"brief explanation of classification\",\n  \"suggestedAction\": \"what should happen next\"\n}`;\n\n    try {\n      const response = await this.geminiService.generateContent(prompt);\n      let result;\n      try {\n        result = JSON.parse(response);\n      } catch (e) {\n        const { parseJsonFromGemini } = await import('@automation/utils');\n        result = parseJsonFromGemini(response) as any;\n      }\n      \n      return {\n        type: result.type || 'question',\n        confidence: result.confidence || 0.5,\n        reasoning: result.reasoning || 'Classification completed',\n        suggestedAction: result.suggestedAction,\n      };\n    } catch (error) {\n      console.error('Error classifying input:', error);\n      // Fallback classification\n      return this.fallbackClassification(input);\n    }\n  }\n\n  private fallbackClassification(input: string): RouterOutput {\n    const inputLower = input.toLowerCase();\n    \n    // Check for question words\n    if (/\\b(what|how|when|where|why|who|which|can|could|should|would|is|are|do|does|did)\\b/i.test(input)) {\n      return {\n        type: 'question',\n        confidence: 0.7,\n        reasoning: 'Contains question words',\n        suggestedAction: 'Route to chat agent',\n      };\n    }\n\n    // Check for reminder keywords\n    if (/\\b(remind|reminder|alert|notify|remember to)\\b/i.test(input)) {\n      return {\n        type: 'reminder',\n        confidence: 0.8,\n        reasoning: 'Contains reminder keywords',\n        suggestedAction: 'Create reminder',\n      };\n    }\n\n    // Check for plan indicators (multiple steps, project words)\n    if (/\\b(plan|project|build|create|develop|learn|study|prepare|organize)\\b/i.test(input) ||\n        input.split(/\\s+/).length > 10) {\n      return {\n        type: 'plan',\n        confidence: 0.7,\n        reasoning: 'Contains plan indicators or is lengthy',\n        suggestedAction: 'Route to planner agent',\n      };\n    }\n\n    // Check for note indicators\n    if (/\\b(note|remember|save|store|info|information|phone|email|address)\\b/i.test(input)) {\n      return {\n        type: 'note',\n        confidence: 0.7,\n        reasoning: 'Contains note indicators',\n        suggestedAction: 'Store as note',\n      };\n    }\n\n    // Default to task\n    return {\n      type: 'task',\n      confidence: 0.6,\n      reasoning: 'Single actionable item',\n      suggestedAction: 'Create task',\n    };\n  }\n}\n"],"names":[],"mappings":";;;;AACA;AAAA;;AAeO,MAAM;IACX,OAAO,SAAS;IACR,cAA6B;IAErC,aAAc;QACZ,IAAI,CAAC,aAAa,GAAG,IAAI,wJAAa;IACxC;IAEA,MAAM,QAAQ,KAAkB,EAA4B;QAC1D,MAAM,EAAE,OAAO,SAAS,EAAE,GAAG;QAE7B,IAAI;YACF,MAAM,iBAAiB,MAAM,IAAI,CAAC,aAAa,CAAC;YAEhD,OAAO;gBACL,QAAQ;gBACR,YAAY,eAAe,UAAU;gBACrC,UAAU;oBACR,WAAW,eAAe,IAAI;oBAC9B,WAAW,eAAe,SAAS;gBACrC;YACF;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0BAA0B;YACxC,OAAO;gBACL,QAAQ;oBACN,MAAM;oBACN,YAAY;oBACZ,WAAW;gBACb;gBACA,YAAY;gBACZ,UAAU;oBAAE,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;gBAAO;YAC5E;QACF;IACF;IAEA,MAAc,cAAc,KAAa,EAAyB;QAChE,MAAM,SAAS,CAAC;;;;;;;;;;;;;;aAcP,EAAE,MAAM;;;;;;;;;;;;;;CAcpB,CAAC;QAEE,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC;YAC1D,IAAI;YACJ,IAAI;gBACF,SAAS,KAAK,KAAK,CAAC;YACtB,EAAE,OAAO,GAAG;gBACV,MAAM,EAAE,mBAAmB,EAAE,GAAG;gBAChC,SAAS,oBAAoB;YAC/B;YAEA,OAAO;gBACL,MAAM,OAAO,IAAI,IAAI;gBACrB,YAAY,OAAO,UAAU,IAAI;gBACjC,WAAW,OAAO,SAAS,IAAI;gBAC/B,iBAAiB,OAAO,eAAe;YACzC;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,0BAA0B;YAC1B,OAAO,IAAI,CAAC,sBAAsB,CAAC;QACrC;IACF;IAEQ,uBAAuB,KAAa,EAAgB;QAC1D,MAAM,aAAa,MAAM,WAAW;QAEpC,2BAA2B;QAC3B,IAAI,qFAAqF,IAAI,CAAC,QAAQ;YACpG,OAAO;gBACL,MAAM;gBACN,YAAY;gBACZ,WAAW;gBACX,iBAAiB;YACnB;QACF;QAEA,8BAA8B;QAC9B,IAAI,kDAAkD,IAAI,CAAC,QAAQ;YACjE,OAAO;gBACL,MAAM;gBACN,YAAY;gBACZ,WAAW;gBACX,iBAAiB;YACnB;QACF;QAEA,4DAA4D;QAC5D,IAAI,wEAAwE,IAAI,CAAC,UAC7E,MAAM,KAAK,CAAC,OAAO,MAAM,GAAG,IAAI;YAClC,OAAO;gBACL,MAAM;gBACN,YAAY;gBACZ,WAAW;gBACX,iBAAiB;YACnB;QACF;QAEA,4BAA4B;QAC5B,IAAI,uEAAuE,IAAI,CAAC,QAAQ;YACtF,OAAO;gBACL,MAAM;gBACN,YAAY;gBACZ,WAAW;gBACX,iBAAiB;YACnB;QACF;QAEA,kBAAkB;QAClB,OAAO;YACL,MAAM;YACN,YAAY;YACZ,WAAW;YACX,iBAAiB;QACnB;IACF;AACF"}},
    {"offset": {"line": 4071, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/packages/agents/src/index.ts"],"sourcesContent":["// Export base agent types\nexport * from './base-agent';\n\n// Export all agent implementations\nexport { PlannerAgent } from './planner-agent';\nexport { SchedulerAgent } from './scheduler-agent';\nexport { PrioritizationAgent } from './prioritization-agent';\nexport { ExecutionAgent } from './execution-agent';\nexport { ReflectionAgent } from './reflection-agent';\nexport { RouterAgent } from './router-agent';\n"],"names":[],"mappings":";AAAA,0BAA0B;AAC1B;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA"}},
    {"offset": {"line": 4092, "column": 0}, "map": {"version":3,"sources":["file:///Users/majedahalshorman/Desktop/Side-Projects/automation/apps/web/apps/web/app/api/agents/planner/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { PlannerAgent } from '@automation/agents';\nimport { userRepo } from '@automation/data';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { goals, constraints, timeframe, forceCreate } = await request.json();\n    \n    // Get or create default user\n    const userId = request.headers.get('x-user-id') || 'default-user';\n    let user = await userRepo.getById(userId);\n    \n    // Create default user if doesn't exist\n    if (!user) {\n      // Create default user with fixed ID\n      user = await userRepo.create({\n        name: 'Default User',\n        email: 'user@example.com',\n        preferences: {\n          workingHours: [],\n          energyProfile: {\n            peakHours: [],\n            mediumHours: [],\n            lowHours: [],\n            recoveryTime: 15,\n          },\n          taskBreakingPreference: 'automatic',\n          schedulingStyle: 'flexible',\n          notificationSettings: {\n            taskReminders: true,\n            scheduleChanges: true,\n            dailySummary: true,\n          },\n        },\n      }, userId); // Use the userId as the ID\n    }\n\n    const plannerAgent = new PlannerAgent();\n    const result = await plannerAgent.process({\n      user,\n      goals,\n      constraints,\n      timeframe: timeframe ? {\n        start: new Date(timeframe.start),\n        end: new Date(timeframe.end)\n      } : undefined,\n      forceCreate: forceCreate || false,\n    } as any);\n\n    // If duplicate detected, return with metadata for frontend handling\n    if (result.metadata?.duplicateDetected) {\n      return NextResponse.json({\n        ...result,\n        requiresConfirmation: true,\n      });\n    }\n\n    return NextResponse.json(result);\n  } catch (error: any) {\n    console.error('Error in planner agent API:', error);\n    return NextResponse.json(\n      { \n        error: error?.message || 'Internal server error',\n        details: error?.stack \n      },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,SAAS,EAAE,WAAW,EAAE,GAAG,MAAM,QAAQ,IAAI;QAEzE,6BAA6B;QAC7B,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;QACnD,IAAI,OAAO,MAAM,qJAAQ,CAAC,OAAO,CAAC;QAElC,uCAAuC;QACvC,IAAI,CAAC,MAAM;YACT,oCAAoC;YACpC,OAAO,MAAM,qJAAQ,CAAC,MAAM,CAAC;gBAC3B,MAAM;gBACN,OAAO;gBACP,aAAa;oBACX,cAAc,EAAE;oBAChB,eAAe;wBACb,WAAW,EAAE;wBACb,aAAa,EAAE;wBACf,UAAU,EAAE;wBACZ,cAAc;oBAChB;oBACA,wBAAwB;oBACxB,iBAAiB;oBACjB,sBAAsB;wBACpB,eAAe;wBACf,iBAAiB;wBACjB,cAAc;oBAChB;gBACF;YACF,GAAG,SAAS,2BAA2B;QACzC;QAEA,MAAM,eAAe,IAAI,+JAAY;QACrC,MAAM,SAAS,MAAM,aAAa,OAAO,CAAC;YACxC;YACA;YACA;YACA,WAAW,YAAY;gBACrB,OAAO,IAAI,KAAK,UAAU,KAAK;gBAC/B,KAAK,IAAI,KAAK,UAAU,GAAG;YAC7B,IAAI;YACJ,aAAa,eAAe;QAC9B;QAEA,oEAAoE;QACpE,IAAI,OAAO,QAAQ,EAAE,mBAAmB;YACtC,OAAO,qWAAY,CAAC,IAAI,CAAC;gBACvB,GAAG,MAAM;gBACT,sBAAsB;YACxB;QACF;QAEA,OAAO,qWAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,qWAAY,CAAC,IAAI,CACtB;YACE,OAAO,OAAO,WAAW;YACzB,SAAS,OAAO;QAClB,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}